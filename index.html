<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <title>ARea Light Editor – GLB Animation Test</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root { color-scheme: dark; }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      display: grid;
      grid-template-columns: minmax(270px, 320px) 1fr;
      height: 100vh;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      background: #050814;
      color: #e5e9f5;
    }
    #panel {
      padding: 16px;
      border-right: 1px solid rgba(255,255,255,0.08);
      background: radial-gradient(circle at top, #121b31, #050814);
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    #panel h1 {
      margin: 0 0 4px;
      font-size: 18px;
    }
    #panel small {
      color: #8891aa;
      line-height: 1.4;
    }
    label {
      font-size: 13px;
      color: #c3c9dc;
      margin-top: 6px;
      display: block;
    }
    input[type="file"],
    select,
    input[type="text"],
    input[type="password"] {
      width: 100%;
      margin-top: 4px;
      padding: 6px 8px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.08);
      background: rgba(6,10,24,0.85);
      color: #e5e9f5;
      font-size: 13px;
    }
    input::placeholder {
      color: #6b7280;
    }
    button {
      border: none;
      border-radius: 999px;
      padding: 8px 14px;
      font-size: 13px;
      cursor: pointer;
      background: linear-gradient(135deg,#4f46e5,#22d3ee);
      color: #fff;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      white-space: nowrap;
    }
    button[disabled] {
      opacity: 0.5;
      cursor: default;
    }
    #btnRow {
      display: flex;
      gap: 8px;
      margin-top: 8px;
      flex-wrap: wrap;
    }
    #status {
      margin-top: 8px;
      font-size: 12px;
      white-space: pre-wrap;
      max-height: 220px;
      overflow: auto;
      background: rgba(4,7,20,0.7);
      border-radius: 8px;
      padding: 8px;
      border: 1px solid rgba(255,255,255,0.06);
    }
    #viewport {
      position: relative;
    }
    canvas {
      display: block;
      width: 100%;
      height: 100%;
    }
    #overlayMsg {
      position: absolute;
      left: 50%;
      top: 16px;
      transform: translateX(-50%);
      padding: 6px 12px;
      border-radius: 999px;
      background: rgba(0,0,0,0.6);
      border: 1px solid rgba(255,255,255,0.12);
      color: #fefefe;
      font-size: 12px;
      pointer-events: none;
    }
    a {
      color: #7dd3fc;
      word-break: break-all;
    }
  </style>
</head>
<body>
  <div id="panel">
    <h1>ARea Light Editor</h1>
    <small>
      Minimal-Setup zum Debuggen:<br>
      <strong>GLB mit Animation → Cloudflare /publish → Surface Viewer</strong>.
    </small>

    <label>
      1. GLB mit Animation importieren
      <input id="fileGlb" type="file" accept=".glb,model/gltf-binary" />
    </label>

    <label>
      2. Animations-Clip wählen
      <select id="clipSelect" disabled>
        <option value="">(noch keine Animationen)</option>
      </select>
    </label>

    <label>
      3. Startmodus
      <select id="startMode">
        <option value="onPlace">onPlace – Start nach AR-Placement</option>
        <option value="onStart">onStart – direkt beim Laden</option>
        <option value="onClick">onClick – bei Tap/Click</option>
        <option value="manual">manual – nur über Buttons</option>
      </select>
    </label>

    <label>
      Szene-ID (optional, sonst wird eine generiert)
      <input id="sceneId" type="text" placeholder="z.B. testcube" />
    </label>

    <label>
      X-AREA-Key (nur lokal, nie im Repo)
      <input id="publishKey" type="password" placeholder="Key aus Cloudflare Worker" />
    </label>

    <div id="btnRow">
      <button id="btnPlay" disabled>▶ Vorschau</button>
      <button id="btnPublish" disabled>⬆ Publish nach Cloudflare</button>
    </div>

    <div id="status"></div>
  </div>

  <div id="viewport">
    <div id="overlayMsg">Importiere ein GLB mit Animation…</div>
    <canvas id="canvas"></canvas>
  </div>

<script type="module">
  // --- CONFIG: Worker & Viewer ----------------------------------------------
  const PUBLISH_URL = 'https://area-publish.area-webar.workers.dev/publish';
  const VIEWER_BASE = 'https://area-viewer.pages.dev/surface-ar/area-viewer.html';

  const workerOrigin = new URL(PUBLISH_URL).origin;
  const KEY_STORAGE = 'area_publish_key';

  // --- Three.js Setup -------------------------------------------------------
  import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
  import { OrbitControls } from 'https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js';
  import { GLTFLoader } from 'https://unpkg.com/three@0.160.0/examples/jsm/loaders/GLTFLoader.js';

  const canvas      = document.getElementById('canvas');
  const overlayMsg  = document.getElementById('overlayMsg');
  const statusEl    = document.getElementById('status');

  const fileGlbInput = document.getElementById('fileGlb');
  const clipSelect   = document.getElementById('clipSelect');
  const startModeSel = document.getElementById('startMode');
  const sceneIdInput = document.getElementById('sceneId');
  const publishKeyInput = document.getElementById('publishKey');
  const btnPlay      = document.getElementById('btnPlay');
  const btnPublish   = document.getElementById('btnPublish');

  // ggf. Key aus localStorage vorbefüllen (nur Browser-seitig)
  const savedKey = localStorage.getItem(KEY_STORAGE);
  if (savedKey) publishKeyInput.value = savedKey;

  function log(msg){
    console.log(msg);
    statusEl.textContent += (statusEl.textContent ? '\n' : '') + msg;
    statusEl.scrollTop = statusEl.scrollHeight;
  }

  const scene   = new THREE.Scene();
  scene.background = new THREE.Color(0x050814);

  const camera  = new THREE.PerspectiveCamera(45, 1, 0.1, 100);
  camera.position.set(2, 2, 3);

  const renderer = new THREE.WebGLRenderer({ canvas, antialias:true });
  renderer.outputColorSpace = THREE.SRGBColorSpace;

  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;

  const hemi = new THREE.HemisphereLight(0xffffff, 0x222233, 1.0);
  scene.add(hemi);

  const dir = new THREE.DirectionalLight(0xffffff, 1.2);
  dir.position.set(3, 5, 4);
  scene.add(dir);

  const groundGeo = new THREE.CircleGeometry(4, 64);
  const groundMat = new THREE.MeshStandardMaterial({
    color: 0x0b1020,
    metalness: 0,
    roughness: 0.9
  });
  const ground = new THREE.Mesh(groundGeo, groundMat);
  ground.rotation.x = -Math.PI/2;
  ground.position.y = -0.01;
  scene.add(ground);

  let mixer = null;
  let currentAction = null;
  let glbAnimations = [];
  let clock = new THREE.Clock();

  let importedGlbBlob = null;
  let importedGlbName = null;

  function resize(){
    const w = canvas.clientWidth || canvas.parentElement.clientWidth;
    const h = canvas.clientHeight || canvas.parentElement.clientHeight;
    camera.aspect = w / h;
    camera.updateProjectionMatrix();
    renderer.setSize(w, h, false);
  }
  window.addEventListener('resize', resize);
  resize();

  function animate(){
    requestAnimationFrame(animate);
    const dt = clock.getDelta();
    if (mixer) mixer.update(dt);
    controls.update();
    renderer.render(scene, camera);
  }
  animate();

  const gltfLoader = new GLTFLoader();

  // --- GLB Import -----------------------------------------------------------
  fileGlbInput.addEventListener('change', async (e)=>{
    const file = e.target.files?.[0];
    if (!file) return;

    statusEl.textContent = '';
    log(`Datei gewählt: ${file.name} (${file.size} Bytes)`);

    if (!file.name.toLowerCase().endsWith('.glb')){
      log('⚠ Nur .glb wird im Light-Editor unterstützt (für Debug).');
      return;
    }

    importedGlbBlob = file;
    importedGlbName = file.name;

    const arrayBuffer = await file.arrayBuffer();

    gltfLoader.parse(arrayBuffer, '', (gltf)=>{
      log('GLB geladen, Szene wird im Viewport angezeigt.');

      // alte Szene räumen (außer Licht/Boden)
      [...scene.children].forEach(ch=>{
        if (ch !== hemi && ch !== dir && ch !== ground) scene.remove(ch);
      });

      const root = gltf.scene || new THREE.Group();
      scene.add(root);

      // zentrieren & skalieren
      const box = new THREE.Box3().setFromObject(root);
      const size = new THREE.Vector3();
      const center = new THREE.Vector3();
      box.getSize(size);
      box.getCenter(center);

      root.position.sub(center);

      const maxDim = Math.max(size.x, size.y, size.z);
      if (maxDim > 0){
        const scale = 1.5 / maxDim;
        root.scale.setScalar(scale);
        log(`Auto-Scaling: maxDim=${maxDim.toFixed(2)}, scale=${scale.toFixed(3)}`);
      }

      camera.position.set(2, 1.5, 3);
      controls.target.set(0, 0.7, 0);
      controls.update();

      // Animationen
      mixer = null;
      glbAnimations = gltf.animations || [];
      if (glbAnimations.length){
        mixer = new THREE.AnimationMixer(root);
        log(`Animationen gefunden: ${glbAnimations.map(a => a.name || '(namenlos)').join(', ')}`);
        fillClipSelect(glbAnimations);
        btnPlay.disabled = false;
        overlayMsg.textContent = 'Animation mit ▶ Vorschau testen – dann Publish.';
      } else {
        log('⚠ Keine Animationen im GLB gefunden (gltf.animations ist leer).');
        clipSelect.innerHTML = '<option value="">(keine Animationen)</option>';
        clipSelect.disabled = true;
        btnPlay.disabled = true;
        overlayMsg.textContent = 'GLB geladen – aber keine Animationen gefunden.';
      }

      btnPublish.disabled = !importedGlbBlob;

    }, (err)=>{
      console.error(err);
      log('Fehler beim Parsen des GLB: ' + err.message);
    });
  });

  function fillClipSelect(anims){
    clipSelect.innerHTML = '';
    anims.forEach((clip, idx)=>{
      const opt = document.createElement('option');
      opt.value = clip.name || String(idx);
      opt.textContent = clip.name || `Clip #${idx}`;
      clipSelect.appendChild(opt);
    });
    clipSelect.disabled = false;
  }

  // --- Vorschau-Play im Editor ----------------------------------------------
  btnPlay.addEventListener('click', ()=>{
    if (!mixer || !glbAnimations.length) return;
    const selName = clipSelect.value || glbAnimations[0].name || '';
    const clip = glbAnimations.find(a => a.name === selName) || glbAnimations[0];

    if (currentAction){
      currentAction.stop();
    }

    currentAction = mixer.clipAction(clip);
    currentAction.reset().setLoop(THREE.LoopRepeat, Infinity).play();
    log(`Vorschau: Animation "${clip.name}" wird abgespielt.`);
  });

  // --- Publish zu Cloudflare /publish --------------------------------------
  btnPublish.addEventListener('click', async ()=>{
    if (!importedGlbBlob){
      log('⚠ Kein GLB geladen – erst Datei importieren.');
      return;
    }

    const PUBLISH_KEY = publishKeyInput.value.trim();
    if (!PUBLISH_KEY){
      log('⚠ Bitte zuerst den X-AREA-Key eingeben (aus Cloudflare Worker).');
      publishKeyInput.focus();
      return;
    }
    // lokal im Browser merken (nicht im Code)
    localStorage.setItem(KEY_STORAGE, PUBLISH_KEY);

    const customId = sceneIdInput.value.trim();
    const sceneId  = customId || ('light-' + Date.now().toString(36));

    const clipName  = (clipSelect.value || '').trim() || (glbAnimations[0]?.name || '*');
    const startMode = startModeSel.value || 'onPlace';

    log(`\n--- Publish startet für Scene-ID "${sceneId}" ---`);
    log(`Clip: ${clipName}, Startmodus: ${startMode}`);

    // Minimale scene.json für den Surface-Viewer
    const sceneConfig = {
      meta: {
        title: sceneId,
        description: '',
        mode: 'area-viewer'
      },
      model: {
        url: 'scene.glb',
        scale: 1
      },
      animation: {
        clipName: clipName,
        start: startMode,
        loop: true,
        iterations: 9999,
        clampWhenFinished: true
      },
      audio: {
        src: null,
        autoplay: 'withAnimation',
        loop: true,
        volume: 0.85
      },
      ui: {
        showPlayPause: true,
        showMute: false,
        showAR: true,
        arLabel: 'In AR öffnen'
      }
    };

    const fd = new FormData();
    fd.append('sceneId', sceneId);
    fd.append('file', importedGlbBlob, 'scene.glb');
    fd.append('file', new Blob(
      [JSON.stringify(sceneConfig, null, 2)],
      { type: 'application/json' }
    ), 'scene.json');

    try{
      const res = await fetch(PUBLISH_URL, {
        method: 'POST',
        headers: { 'X-AREA-Key': PUBLISH_KEY },
        body: fd
      });

      if (!res.ok){
        const txt = await res.text().catch(()=> '');
        throw new Error(res.status + ' ' + res.statusText + (txt ? ' – ' + txt : ''));
      }

      const data = await res.json().catch(()=> ({}));
      log('Publish erfolgreich. Worker-Antwort: ' + JSON.stringify(data, null, 2));

      const returnedId   = data.sceneId || sceneId;
      const viewerUrlRaw = data.viewerUrl || (
        `${VIEWER_BASE}?scene=${encodeURIComponent(returnedId)}&base=${encodeURIComponent(workerOrigin)}`
      );

      log('\nViewer-URL:');
      log(viewerUrlRaw);

      window.open(viewerUrlRaw, '_blank');

    } catch (e){
      console.error(e);
      log('❌ Publish fehlgeschlagen: ' + e.message);
    }
  });
</script>
</body>
</html>
