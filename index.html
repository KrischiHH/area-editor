<!-- === Variante A: Original-GLB Passthrough (Animationen erhalten) === -->
<script>
(function(){
  const AREA = (window.__AREA = window.__AREA || {});
  AREA.__origGlb = null;

  // Datei-Upload-Listener erst binden, wenn DOM steht
  window.addEventListener('DOMContentLoaded', ()=>{
    const fileGlbInput = document.getElementById('file-glb');
    if (fileGlbInput) {
      fileGlbInput.addEventListener('change', async (ev)=>{
        try{
          const f = ev.target.files && ev.target.files[0];
          if (!f) return;
          AREA.__origGlb = await f.arrayBuffer();
          console.log('[editor] Original GLB gepuffert (Datei):', f.name, AREA.__origGlb.byteLength, 'Bytes');
        }catch(e){ console.warn('[editor] GLB-Puffer fehlgeschlagen:', e); }
      });
    }

    // Optional: Reset beim „Szene leeren“ / „Neu“
    try {
      const btnClear = document.getElementById('btn-clear');
      btnClear && btnClear.addEventListener('click', ()=>{ AREA.__origGlb = null; });
      const btnNew = document.getElementById('btn-new');
      btnNew && btnNew.addEventListener('click', ()=>{ AREA.__origGlb = null; });
    } catch(_) {}
  });

  // URL-Import: im jeweiligen Flow (z. B. nach URL-Bestätigung) aktiv aufrufen
  AREA.rememberOriginalGlbFromUrl = async function(glbUrl){
    try{
      if (!/^https?:\/\//i.test(glbUrl)) return;
      const r = await fetch(glbUrl, { mode:'cors', credentials:'omit' });
      if (!r.ok){ console.warn('[editor] GLB-URL fetch fehlgeschlagen:', r.status, r.statusText); return; }
      AREA.__origGlb = await r.arrayBuffer();
      console.log('[editor] Original GLB gepuffert (URL):', glbUrl, AREA.__origGlb.byteLength, 'Bytes');
    }catch(e){ console.warn('[editor] GLB-URL Puffer fehlgeschlagen:', e); }
  };

  // animations[]-Check im GLB
  window.hasAnimationsInGlbBlob = async function hasAnimationsInGlbBlob(blob){
    try{
      const ab = await blob.arrayBuffer();
      const dv = new DataView(ab);
      if (dv.getUint32(0, true) !== 0x46546c67) return false; // 'glTF'
      if (dv.getUint32(4, true) < 2) return false;            // v2+

      const jsonLength = dv.getUint32(12, true);
      const jsonType   = dv.getUint32(16, true);
      if (jsonType !== 0x4E4F534A) return false; // 'JSON'
      const jsonStr = new TextDecoder().decode(new Uint8Array(ab, 20, jsonLength));
      try {
        const j = JSON.parse(jsonStr);
        return Array.isArray(j.animations) && j.animations.length > 0;
      } catch {
        return /"animations"\s*:\s*\[/.test(jsonStr);
      }
    } catch(e){
      console.warn('[editor] hasAnimationsInGlbBlob failed:', e);
      return false;
    }
  };

  // Fetch-Wrapper: Publish-Fallback (Hotfix #1)
  // TODO: Remove fallback once export reliably contains animations[]
  const _origFetch = window.fetch.bind(window);
  window.fetch = async (input, init)=>{
    if (!init) init = {};
    const method = init.method ? String(init.method).toUpperCase() : 'GET';
    if (method !== 'POST') return _origFetch(input, init);
    if (!(init.body instanceof FormData)) return _origFetch(input, init);
    if (!AREA.__origGlb) return _origFetch(input, init);

    try{
      let urlString = '';
      if (typeof input === 'string') {
        urlString = input;
      } else if (input && typeof input.url === 'string') {
        urlString = input.url;
      } else {
        return _origFetch(input, init);
      }

      const urlObj = new URL(urlString, location.href);
      const isPublish = /\/publish\/?$/.test(urlObj.pathname);
      if (!isPublish) return _origFetch(input, init);

      const fdOld = init.body;
      const fdNew = new FormData();
      let exporterSceneGlb = null;

      for (const [k,v] of fdOld.entries()){
        if (k === 'file' && v && typeof v.name === 'string' && /scene\.glb$/i.test(v.name || '')){
          exporterSceneGlb = v;
          continue;
        }
        fdNew.append(k, v);
      }

      let chosenGlb = null;
      if (!exporterSceneGlb){
        chosenGlb = new Blob([AREA.__origGlb], { type:'model/gltf-binary' });
        console.log('[editor] Publish: Original scene.glb angehängt (', AREA.__origGlb.byteLength, 'Bytes );');
      } else {
        const hasAnim = await window.hasAnimationsInGlbBlob(exporterSceneGlb);
        if (hasAnim){
          chosenGlb = exporterSceneGlb;
          console.log('[editor] Publish: Exporter-GLB mit animations[] verwendet.');
        } else {
          chosenGlb = new Blob([AREA.__origGlb], { type:'model/gltf-binary' });
          console.log('[editor] Exportiertes GLB ohne animations[] – fallback auf Original-GLB.');
        }
      }

      fdNew.append('file', chosenGlb, 'scene.glb');
      init = { ...init, body: fdNew };
    }catch(e){ 
      console.warn('[editor] fetch wrapper warn:', e); 
      return _origFetch(input, init);
    }
    return _origFetch(input, init);
  };
})();
</script>

