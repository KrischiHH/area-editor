async function publish(){
  const cfg = window.__AREA || {};
  const EP  = (cfg.PUBLISH_ENDPOINT || '').trim();
  const KEY = (cfg.PUBLISH_KEY || '').trim(); // optional – wird nur gesendet, wenn vorhanden

  if (!EP) {
    alert('Publish ist nicht konfiguriert: window.__AREA.PUBLISH_ENDPOINT fehlt.');
    return;
  }

  try {
    const defaultId = sanitizeId(projectName);
    const sceneId   = sanitizeId(prompt('Scene ID:', defaultId) || defaultId);

    toast('Exportiere Szene…');

    // GLB exportieren + Magic-Bytes check
    let glbBlob = await exportSceneGLB();
    const ab = await glbBlob.arrayBuffer();
    const u8 = new Uint8Array(ab, 0, 4);
    if (!(u8[0]===0x67 && u8[1]===0x6C && u8[2]===0x54 && u8[3]===0x46)) {
      throw new Error('Exportierte Datei ist kein GLB (fehlende "glTF"-Magic-Bytes).');
    }

    const mode = (document.getElementById('anchorMode')?.value || 'surface-webxr');

    // Upload-Payload
    const form = new FormData();
    form.append('sceneId', sceneId);
    form.append('file', new File([glbBlob], 'scene.glb', { type:'model/gltf-binary' }));

    if (mode === 'scene-viewer') {
      // Poster: bevorzugt Nutzer-Upload, sonst Canvas-Snapshot
      let posterBlob = null;
      if (typeof customPosterBlob !== 'undefined' && customPosterBlob) {
        posterBlob = customPosterBlob;
      } else {
        try { posterBlob = await capturePosterBlob(0.9); } catch {}
      }
      if (posterBlob) {
        form.append('file', new File([posterBlob], 'poster.jpg', { type:'image/jpeg' }));
      }

      // optional: erstes Audio mitsenden
      const a = findFirstAudio();
      if (a){
        const audioBlob = a.fromFile ? a.fromFile : (a.fromDataUrl ? await dataUrlToBlob(a.fromDataUrl) : null);
        if (audioBlob){
          form.append('file', new File([audioBlob], 'audio.mp3', { type:(audioBlob.type||'audio/mpeg') }));
        }
      }

      // Scene-Viewer JSON (RELATIVE URLs über Worker-Base)
      const workerOrigin = new URL(EP).origin;
      const sceneJsonSV = buildSceneViewerJSON_CF({ sceneId, workerOrigin });
      form.append('file', new File([JSON.stringify(sceneJsonSV, null, 2)], 'scene.json', { type:'application/json' }));

    } else {
      // WebXR / Native / Image: einfache scene.json + ggf. native URLs
      const workerOrigin = new URL(EP).origin;
      const sceneBase    = `${workerOrigin}/scenes/${encodeURIComponent(sceneId)}`;

      const glbUrl  = (mode === 'native' && (document.getElementById('nativeGlbUrl')?.value||'').trim())
                        ? document.getElementById('nativeGlbUrl').value.trim()
                        : `${sceneBase}/scene.glb`;
      const usdzUrl = (mode === 'native' && (document.getElementById('nativeUsdzUrl')?.value||'').trim())
                        ? document.getElementById('nativeUsdzUrl').value.trim()
                        : null;
      const targetUrl = (mode === 'image' && (document.getElementById('imageTargetUrl')?.value||'').trim())
                        ? document.getElementById('imageTargetUrl').value.trim()
                        : null;

      const sceneJson = buildSceneJSON({
        sceneId,
        title: projectName,
        mode,
        glbUrl,
        usdzUrl,
        targetUrl
      });
      form.append('file', new File([JSON.stringify(sceneJson, null, 2)], 'scene.json', { type:'application/json' }));
    }

    toast('Lade hoch…');

    // Header: Accept immer, Key nur wenn vorhanden
    const headers = { 'Accept': 'application/json' };
    if (KEY) headers['X-AREA-Key'] = KEY;

    const res = await fetch(EP, { method:'POST', body: form, headers });
    if (!res.ok) {
      const t = await res.text().catch(()=> '');
      throw new Error(t || ('HTTP '+res.status));
    }

    const json = await res.json().catch(()=> ({}));

    // Viewer-URL (deine funktionierenden Pfade beibehalten)
    const viewerBase  = (cfg.VIEWER_BASE || 'https://area-viewer.pages.dev');
    const entryByMode = {
      'surface-webxr': '/webxr.html',
      'native':        '/index.html',
      'image':         '/image-ar/viewer.html',
      'scene-viewer':  '/scene-viewer/index.html'
    };
    const entry = entryByMode[mode] || '/webxr.html';
    const workerOrigin = new URL(EP).origin;

    // Fallback, falls der Worker nichts zurückgibt
    let url = json.viewerUrl
           || `${viewerBase}${entry}?scene=${encodeURIComponent(sceneId)}&base=${encodeURIComponent(workerOrigin)}`;

    // base-Param absichern (kein „internal“ etc.)
    try {
      const u = new URL(url);
      const b = (u.searchParams.get('base') || '').trim();
      if (!b || b === 'internal' || b === 'https://internal' || b === 'http://internal') {
        u.searchParams.set('base', workerOrigin);
      }
      url = u.toString();
    } catch {}

    showSharePanel(url);
    try { await navigator.clipboard.writeText(url); } catch {}
    toast('Veröffentlicht');

  } catch (err) {
    console.error(err);
    alert('Publish fehlgeschlagen: ' + (err?.message || err));
  }
}
