async function publish(){
  const cfg = window.__AREA || {};
  const EP  = (cfg.PUBLISH_ENDPOINT || '').trim();
  const KEY = (cfg.PUBLISH_KEY || '').trim(); // optional – wird nur gesendet, wenn vorhanden

  if (!EP) {
    alert('Publish ist nicht konfiguriert: window.__AREA.PUBLISH_ENDPOINT fehlt.');
    return;
  }

  try {
    const defaultId = sanitizeId(projectName);
    const sceneId   = sanitizeId(prompt('Scene ID:', defaultId) || defaultId);

    toast('Exportiere Szene…');

    // GLB exportieren + Magic-Bytes check
    let glbBlob = await exportSceneGLB();
    const ab = await glbBlob.arrayBuffer();
    const u8 = new Uint8Array(ab, 0, 4);
    if (!(u8[0]===0x67 && u8[1]===0x6C && u8[2]===0x54 && u8[3]===0x46)) {
      throw new Error('Exportierte Datei ist kein GLB (fehlende "glTF"-Magic-Bytes).');
    }

    const mode = (document.getElementById('anchorMode')?.value || 'surface-webxr');

    // 1) Robust PUBLISH_ENDPOINT parsing and workerOrigin fallback
    // Support relative EP values (e.g., "/api/publish") and absolute URLs
    let workerOrigin;
    try {
      const epUrl = new URL(EP, location.href);
      workerOrigin = epUrl.origin;
    } catch {
      // Fallback if EP is malformed
      workerOrigin = location.origin;
    }

    // Check if we should use editor/local base for preview links
    // (e.g., when anchorMode indicates 'editor-local' or 'local')
    const isLocalPreview = (mode === 'editor-local' || mode === 'local');
    if (isLocalPreview && cfg.EDITOR_WORKER_BASE) {
      try {
        const editorBaseUrl = new URL(cfg.EDITOR_WORKER_BASE, location.href);
        workerOrigin = editorBaseUrl.origin;
      } catch {
        // If EDITOR_WORKER_BASE is malformed, use location.origin
        workerOrigin = location.origin;
      }
    }

    // Upload-Payload
    // NOTE: FormData fields use multiple 'file' entries for backward compatibility
    // with existing backend. If server is updated in future, consider using explicit
    // field names: 'glb', 'poster', 'audio', 'sceneJson' for clearer semantics.
    const form = new FormData();
    form.append('sceneId', sceneId);
    form.append('file', new File([glbBlob], 'scene.glb', { type:'model/gltf-binary' }));

    if (mode === 'scene-viewer') {
      // Poster: bevorzugt Nutzer-Upload, sonst Canvas-Snapshot
      let posterBlob = null;
      if (typeof customPosterBlob !== 'undefined' && customPosterBlob) {
        posterBlob = customPosterBlob;
      } else {
        try { posterBlob = await capturePosterBlob(0.9); } catch {}
      }
      if (posterBlob) {
        form.append('file', new File([posterBlob], 'poster.jpg', { type:'image/jpeg' }));
      }

      // optional: erstes Audio mitsenden
      const a = findFirstAudio();
      if (a){
        const audioBlob = a.fromFile ? a.fromFile : (a.fromDataUrl ? await dataUrlToBlob(a.fromDataUrl) : null);
        if (audioBlob){
          form.append('file', new File([audioBlob], 'audio.mp3', { type:(audioBlob.type||'audio/mpeg') }));
        }
      }

      // Scene-Viewer JSON (RELATIVE URLs über Worker-Base)
      const sceneJsonSV = buildSceneViewerJSON_CF({ sceneId, workerOrigin });
      form.append('file', new File([JSON.stringify(sceneJsonSV, null, 2)], 'scene.json', { type:'application/json' }));

    } else {
      // WebXR / Native / Image: einfache scene.json + ggf. native URLs
      const sceneBase    = `${workerOrigin}/scenes/${encodeURIComponent(sceneId)}`;

      const glbUrl  = (mode === 'native' && (document.getElementById('nativeGlbUrl')?.value||'').trim())
                        ? document.getElementById('nativeGlbUrl').value.trim()
                        : `${sceneBase}/scene.glb`;
      const usdzUrl = (mode === 'native' && (document.getElementById('nativeUsdzUrl')?.value||'').trim())
                        ? document.getElementById('nativeUsdzUrl').value.trim()
                        : null;
      const targetUrl = (mode === 'image' && (document.getElementById('imageTargetUrl')?.value||'').trim())
                        ? document.getElementById('imageTargetUrl').value.trim()
                        : null;

      const sceneJson = buildSceneJSON({
        sceneId,
        title: projectName,
        mode,
        glbUrl,
        usdzUrl,
        targetUrl
      });
      form.append('file', new File([JSON.stringify(sceneJson, null, 2)], 'scene.json', { type:'application/json' }));
    }

    toast('Lade hoch…');

    // Header: Accept immer, Key nur wenn vorhanden
    const headers = { 'Accept': 'application/json' };
    if (KEY) headers['X-AREA-Key'] = KEY;

    const res = await fetch(EP, { method:'POST', body: form, headers });
    if (!res.ok) {
      const t = await res.text().catch(()=> '');
      throw new Error(t || ('HTTP '+res.status));
    }

    const json = await res.json().catch(()=> ({}));

    // Viewer-URL (deine funktionierenden Pfade beibehalten)
    const viewerBase  = (cfg.VIEWER_BASE || 'https://area-viewer.pages.dev');
    const entryByMode = {
      'surface-webxr': '/webxr.html',
      'native':        '/index.html',
      'image':         '/image-ar/viewer.html',
      'scene-viewer':  '/scene-viewer/index.html'
    };
    const entry = entryByMode[mode] || '/webxr.html';

    let url;
    if (json.viewerUrl) {
      // 2) Normalize server-provided viewerUrl to absolute URL using viewerBase as base
      try {
        const viewerUrl = new URL(json.viewerUrl, viewerBase);
        url = viewerUrl.toString();
      } catch {
        // If malformed, fall back to constructing URL ourselves
        url = `${viewerBase}${entry}?scene=${encodeURIComponent(sceneId)}&base=${encodeURIComponent(workerOrigin)}`;
      }
    } else {
      // Fallback if server doesn't return viewerUrl
      url = `${viewerBase}${entry}?scene=${encodeURIComponent(sceneId)}&base=${encodeURIComponent(workerOrigin)}`;
    }

    // 3) Improve base query param validation
    // Validate 'base' param accepts only valid origins (protocol + hostname + optional port)
    try {
      const u = new URL(url);
      const b = (u.searchParams.get('base') || '').trim();
      
      // Validate base parameter
      let validBase = false;
      if (b) {
        try {
          const baseUrl = new URL(b);
          // Check if it's a valid origin (has protocol and hostname)
          validBase = !!(baseUrl.protocol && baseUrl.hostname);
        } catch {
          validBase = false;
        }
      }
      
      // If base is missing or invalid, set to workerOrigin
      if (!validBase) {
        u.searchParams.set('base', workerOrigin);
      }
      
      url = u.toString();
    } catch {}

    // 6) Small UX: mark shared URL as 'preview' when base is location.origin or editor base
    // Append '&preview=1' if base is editor-local origin
    try {
      const u = new URL(url);
      const base = u.searchParams.get('base') || '';
      
      // Check if base is local/editor origin
      const isPreviewUrl = (base === location.origin) || 
                          (cfg.EDITOR_WORKER_BASE && base === new URL(cfg.EDITOR_WORKER_BASE, location.href).origin) ||
                          isLocalPreview;
      
      if (isPreviewUrl) {
        u.searchParams.set('preview', '1');
        url = u.toString();
      }
    } catch {}

    showSharePanel(url);
    try { await navigator.clipboard.writeText(url); } catch {}
    toast('Veröffentlicht');

  } catch (err) {
    console.error(err);
    alert('Publish fehlgeschlagen: ' + (err?.message || err));
  }
}
