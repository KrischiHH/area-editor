<!doctype html>
<html lang="de" class="theme-slate">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ARea Editor v3.0</title>
  <script>
(function(){
  try{
    var t = localStorage.getItem('theme') || 'theme-nebula';
    var html = document.documentElement;
    ['theme-slate','theme-aurora','theme-nebula'].forEach(c=>html.classList.remove(c));
    html.classList.add(t);
  }catch{}
})();
</script>
  <style>
    :root { color-scheme: dark; } /* nur Globales hier rein */

    /* ===================== Themes ===================== */
    :root.theme-slate{
      --bg:#161b23; --panel:#111828; --panel2:#192339; --text:#e9ecf5;
      --muted:#9fb3d9; --border:#24314a; --accent:#60a5fa; --accent2:#93c5fd;
      color-scheme: dark;
    }

    /* Aurora: deutlich anders (türkise Akzente, grünlich-dunkler Hintergrund) */
    :root.theme-aurora{
      --bg:#062026;
      --panel:#06242b;
      --panel2:#08323c;
      --text:#e6fffb;
      --muted:#93d9d1;
      --border:#0f3a43;
      --accent:#22d3ee;
      --accent2:#67e8f9;
      color-scheme: dark;
    }

    /* schlichtes Logo ohne Hintergrund/Pill */
.top .brand-logo{
  display:inline-flex;
  align-items:center;
  padding:0;
  margin-right:8px;
  border:none;
  background:transparent;
}
.top .brand-logo img{
  height:50px;
  width:auto;
  display:block;
  border-radius:0;
  box-shadow:none;
  opacity:1;
}

    html, body,
    .panel, .btn, .menubtn, .menu-pop, .toolbtn, .status-badge, .status-pill,
    .icon, .tab, .del, .select, .input, .section > summary {
      transition: background-color .25s ease, color .25s ease, border-color .25s ease, box-shadow .25s ease;
    }

    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font:14px/1.45 system-ui,Segoe UI,Inter,Roboto,Arial,sans-serif}
    .top{height:56px;display:flex;gap:8px;align-items:center;padding:0 12px;background:var(--panel);border-bottom:1px solid var(--border);position:relative;z-index:10}
    .brand{font-weight:800;letter-spacing:.02em}
    .ver{opacity:.75;margin-left:6px}
    .muted{color:var(--muted)}
    .sp{flex:1}
    .btn{background:var(--panel2);border:1px solid var(--border);color:var(--text);padding:8px 10px;border-radius:10px;cursor:pointer;font-weight:700}
    .btn:hover{border-color:var(--accent)}
    .btn:disabled,.toolbtn:disabled{opacity:.5;cursor:not-allowed}

    .wrap{
      height:calc(100vh - 56px);
      display:grid;
      grid-template-columns:minmax(220px,280px) minmax(320px,1fr) minmax(280px,420px);
      gap:10px;padding:10px;overflow:hidden
    }
    @media (max-width:1000px){.wrap{grid-template-columns:minmax(200px,260px) minmax(320px,1fr)} .wrap>.panel:nth-child(3){grid-column:1/-1}}
    @media (max-width:680px){.wrap{grid-template-columns:1fr}}

    .panel{background:var(--panel);border:1px solid var(--border);border-radius:14px;overflow:hidden;display:flex;flex-direction:column;min-height:0}
    .panel h3{margin:0;padding:10px 12px;border-bottom:1px solid var(--border);font-size:12px;color:var(--muted);text-transform:uppercase;letter-spacing:.08em}
    .content{padding:10px;overflow:auto}

    /* ===================== Theme: Nebula ===================== */
:root.theme-nebula{
  --bg:#080e19;
  --bg-grad:
    radial-gradient(1100px 800px at 12% 0%,  #2c3f84 0%,  transparent 58%),
    radial-gradient(1200px 900px at 88% 8%, #6d3a99 0%,  transparent 60%),
    radial-gradient(900px 700px  at 18% 86%, #2d6bb4 0%, transparent 62%),
    linear-gradient(180deg, #0a0f1e 0%, #10182a 100%);
  --glass:       rgba(255,255,255,0.07);
  --glass-2:     rgba(255,255,255,0.10);
  --glass-border:rgba(255,255,255,0.18);
  --glass-blur:  14px;
  --panel:#0e1424;
  --panel2:#121a2e;
  --text:#e8eefb;
  --muted:#a9b7da;
  --border:#1e2a45;
  --accent:#7dd3fc;
  --accent2:#a78bfa;
  color-scheme: dark;
}

:root.theme-nebula body{ background:#0a0f1e; }
:root.theme-nebula body::before{
  content:""; position:fixed; inset:0; z-index:-1; pointer-events:none;
  background: var(--bg-grad);
}

:root.theme-nebula .top,
:root.theme-nebula .panel,
:root.theme-nebula .menu-pop,
:root.theme-nebula .btn,
:root.theme-nebula .menubtn,
:root.theme-nebula .toolbtn,
:root.theme-nebula .status-badge,
:root.theme-nebula .status-pill,
:root.theme-nebula .input,
:root.theme-nebula .select,
:root.theme-nebula .icon,
:root.theme-nebula .del,
:root.theme-nebula .dropzone{
  background: var(--glass);
  border-color: var(--glass-border);
  -webkit-backdrop-filter: blur(var(--glass-blur));
          backdrop-filter: blur(var(--glass-blur));
  box-shadow:
    0 12px 30px rgba(0,0,0,.38),
    inset 0 1px 0 rgba(255,255,255,.08);
}

:root.theme-nebula .panel{
  border-radius:18px;
  box-shadow:
    0 16px 44px rgba(0,0,0,.46),
    0 0 0 1px rgba(255,255,255,.06),
    0 0 40px -8px color-mix(in srgb, var(--accent2) 45%, transparent);
}

:root.theme-nebula .top{
  border-radius: 0 0 18px 18px;
  background:
    linear-gradient(135deg, rgba(125,211,252,.20), rgba(167,139,250,.14)),
    var(--glass);
  border-bottom-color: var(--glass-border);
}

/* ... (CSS bleibt unverändert; gekürzt für Übersicht) ... */

/* Uiverse-Style Sweep etc ... (restliche CSS aus Original) */

:root{
  --ui-font: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto,
             "Helvetica Neue", Arial, "Apple Color Emoji",
             "Segoe UI Emoji", "Segoe UI Symbol", sans-serif;
}
html, body { font-family: var(--ui-font); }
.btn, .menubtn, .toolbtn, .tab, .status-pill, .menuitem,
.input, .select, .panel h3 { font-family: var(--ui-font); }

#left > h3{
  display:flex; align-items:center; gap:8px;
  color: var(--muted);
}
#left > h3::before{
  content:"";
  display:inline-block;
  width:16px; height:16px; flex:0 0 16px;
  background: url("https://raw.githubusercontent.com/KrischiHH/area/main/icons/layer_icon.png")
              center / contain no-repeat;
  opacity:.95;
}
@supports (-webkit-mask: url("")) or (mask: url("")){
  #left > h3::before{
    background-color: currentColor;
    -webkit-mask: url("https://raw.githubusercontent.com/KrischiHH/area/main/icons/layer_icon.svg") no-repeat center / contain;
            mask: url("https://raw.githubusercontent.com/KrischiHH/area/main/icons/layer_icon.svg") no-repeat center / contain;
  }
}
/* ===================== FEHLENDE STYLES FÜR MENÜ & VIEWPORT ===================== */

/* Viewport Container */
.viewport {
  background: var(--panel);
  border: 1px solid var(--border);
  border-radius: 14px;
  overflow: hidden;
  display: flex;
  flex-direction: column;
  position: relative;
  min-height: 0;
}

#stage {
  width: 100%;
  height: 100%;
  flex: 1;
  position: relative;
  overflow: hidden;
  min-width: 320px;
  min-height: 240px;
}

/* Projekt-Menü */
.menu {
  position: relative;
  display: inline-block;
}

.menubtn {
  background: var(--panel2);
  border: 1px solid var(--border);
  color: var(--text);
  padding: 8px 12px;
  border-radius: 10px;
  cursor: pointer;
  font-weight: 700;
  font-size: 14px;
  transition: all 0.2s;
}

.menubtn:hover {
  border-color: var(--accent);
}

.menu-pop {
  display: none;
  position: absolute;
  top: 100%;
  left: 0;
  margin-top: 4px;
  background: var(--panel);
  border: 1px solid var(--border);
  border-radius: 10px;
  padding: 4px;
  min-width: 220px;
  z-index: 1000;
  box-shadow: 0 8px 24px rgba(0,0,0,0.3);
}

.menu.open .menu-pop {
  display: block;
}

.menuitem {
  display: block;
  width: 100%;
  padding: 10px 12px;
  background: transparent;
  border: none;
  color: var(--text);
  text-align: left;
  cursor: pointer;
  border-radius: 6px;
  font-size: 14px;
  transition: background-color 0.2s;
}

.menuitem:hover {
  background: var(--panel2);
}

.menuitem input[type="file"] {
  display: none;
}

/* UI Pills */
.ui-pill {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  padding: 8px 12px;
  background: var(--panel2);
  border: 1px solid var(--border);
  border-radius: 10px;
  color: var(--text);
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s;
}

.ui-pill:hover {
  border-color: var(--accent);
  background: var(--panel);
}

.ui-pill input[type="file"] {
  display: none;
}

/* Status Pills */
.status-pill {
  display: inline-flex;
  align-items: center;
  padding: 6px 10px;
  background: var(--panel2);
  border: 1px solid var(--border);
  border-radius: 8px;
  color: var(--text);
  font-size: 12px;
  font-weight: 600;
}

#vpStatus {
  position: absolute;
  top: 12px;
  right: 12px;
  display: flex;
  gap: 6px;
  z-index: 100;
}

/* Hint FAB */
.hint-fab {
  position: absolute;
  bottom: 16px;
  right: 16px;
  width: 36px;
  height: 36px;
  border-radius: 50%;
  background: var(--accent);
  color: white;
  border: none;
  cursor: pointer;
  font-weight: 700;
  font-size: 16px;
  box-shadow: 0 4px 12px rgba(0,0,0,0.3);
  z-index: 100;
  transition: all 0.2s;
}

.hint-fab:hover {
  transform: scale(1.1);
}

.hint {
  position: absolute;
  bottom: 64px;
  right: 16px;
  background: var(--panel);
  border: 1px solid var(--border);
  border-radius: 10px;
  padding: 12px;
  max-width: 320px;
  font-size: 13px;
  line-height: 1.5;
  box-shadow: 0 8px 24px rgba(0,0,0,0.3);
  z-index: 99;
}

.hint.hidden {
  display: none;
}

/* Theme Toggle (3-Wege-Switch) */
.theme-toggle3 {
  position: relative;
  display: inline-flex;
  background: var(--panel2);
  border: 1px solid var(--border);
  border-radius: 8px;
  padding: 2px;
  gap: 0;
}

.theme-toggle3 input {
  position: absolute;
  opacity: 0;
  pointer-events: none;
}

.theme-toggle3 label {
  padding: 6px 12px;
  cursor: pointer;
  font-size: 13px;
  font-weight: 600;
  color: var(--muted);
  transition: color 0.2s;
  z-index: 2;
  position: relative;
  min-width: 32px;
  text-align: center;
}

.theme-toggle3 input:checked + label {
  color: var(--text);
}

.theme-toggle3 .thumb {
  position: absolute;
  top: 2px;
  left: 2px;
  bottom: 2px;
  width: calc(33.333% - 1.5px);
  background: var(--accent);
  border-radius: 6px;
  transition: transform 0.25s ease;
  z-index: 1;
}

.theme-toggle3 input:nth-of-type(1):checked ~ .thumb {
  transform: translateX(0);
}

.theme-toggle3 input:nth-of-type(2):checked ~ .thumb {
  transform: translateX(100%);
}

.theme-toggle3 input:nth-of-type(3):checked ~ .thumb {
  transform: translateX(200%);
}

/* Toolbar */
.toolbar {
  display: flex;
  gap: 6px;
  margin-bottom: 8px;
  flex-wrap: wrap;
}

.toolbtn {
  background: var(--panel2);
  border: 1px solid var(--border);
  color: var(--text);
  padding: 6px 10px;
  border-radius: 8px;
  cursor: pointer;
  font-size: 13px;
  font-weight: 600;
  transition: all 0.2s;
}

.toolbtn:hover {
  border-color: var(--accent);
}

.toolbtn.active {
  background: var(--accent);
  border-color: var(--accent);
  color: white;
}

/* Section (Collapsible) */
.section {
  border: 1px solid var(--border);
  border-radius: 10px;
  margin-bottom: 10px;
  overflow: hidden;
}

.section > summary {
  padding: 10px 12px;
  cursor: pointer;
  list-style: none;
  display: flex;
  justify-content: space-between;
  align-items: center;
  background: var(--panel2);
  font-weight: 600;
  font-size: 13px;
  transition: background-color 0.2s;
}

.section > summary:hover {
  background: var(--panel);
}

.section > summary::-webkit-details-marker {
  display: none;
}

.section .body {
  padding: 12px;
}

.section .sum-title {
  flex: 1;
}

.section .sum-icons {
  display: flex;
  gap: 8px;
  align-items: center;
}

.ico-mask {
  width: 16px;
  height: 16px;
  display: inline-block;
  background: var(--muted);
}

.ico--chev {
  transition: transform 0.2s;
}

.section[open] .ico--chev {
  transform: rotate(180deg);
}

/* Key-Value Rows */
.kv {
  display: grid;
  grid-template-columns: 120px 1fr;
  gap: 8px;
  align-items: center;
  margin-bottom: 8px;
  font-size: 13px;
}

.kv > div:first-child {
  color: var(--muted);
  font-weight: 600;
}

/* Input & Select */
.input, .select {
  background: var(--panel2);
  border: 1px solid var(--border);
  color: var(--text);
  padding: 6px 8px;
  border-radius: 6px;
  font-size: 13px;
  width: 100%;
}

.input:focus, .select:focus {
  outline: none;
  border-color: var(--accent);
}

/* Scene List */
#sceneList .row {
  display: flex;
  gap: 6px;
  align-items: center;
  margin-bottom: 4px;
}

#sceneList .icon {
  width: 24px;
  height: 24px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  font-size: 14px;
  border-radius: 4px;
  transition: background-color 0.2s;
}

#sceneList .icon:hover {
  background: var(--panel2);
}

#sceneList .tab {
  flex: 1;
  background: var(--panel2);
  border: 1px solid var(--border);
  color: var(--text);
  padding: 6px 8px;
  border-radius: 6px;
  cursor: pointer;
  text-align: left;
  font-size: 13px;
  transition: all 0.2s;
}

#sceneList .tab:hover {
  border-color: var(--accent);
}

#sceneList .tab.active {
  background: var(--accent);
  border-color: var(--accent);
  color: white;
}

#sceneList .del {
  background: transparent;
  border: 1px solid var(--border);
  color: var(--muted);
  width: 24px;
  height: 24px;
  border-radius: 4px;
  cursor: pointer;
  font-size: 16px;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s;
}

#sceneList .del:hover {
  background: #ff4444;
  border-color: #ff4444;
  color: white;
}

/* Dropzone */
.dropzone {
  border: 2px dashed var(--border);
  border-radius: 8px;
  padding: 16px;
  text-align: center;
  cursor: pointer;
  transition: all 0.2s;
  background: var(--panel2);
}

.dropzone:hover, .dropzone.hover {
  border-color: var(--accent);
  background: var(--panel);
}

.dropzone .preview img {
  max-width: 100%;
  height: auto;
  border-radius: 6px;
  margin-bottom: 8px;
}

/* Toast */
.toast {
  position: fixed;
  bottom: 20px;
  left: 50%;
  transform: translateX(-50%);
  background: var(--panel);
  border: 1px solid var(--border);
  color: var(--text);
  padding: 12px 20px;
  border-radius: 10px;
  box-shadow: 0 8px 24px rgba(0,0,0,0.3);
  z-index: 9999;
  font-size: 14px;
  font-weight: 600;
  display: none;
}

/* Sweep Effect */
.sweep {
  position: relative;
  overflow: hidden;
}

.sweep::before {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent);
  transition: left 0.5s;
}

.sweep:hover::before {
  left: 100%;
}

/* UI Tooltip */
.ui-tooltip {
  background: var(--panel);
  border: 1px solid var(--border);
  box-shadow: 0 8px 24px rgba(0,0,0,0.3);
}
  </style>

  <!-- Minimal Config -->
<script>
  window.__AREA = {
    PUBLISH_ENDPOINT: "https://area-publish-proxy.area-webar.workers.dev/publish",
    FILE_BASE:       "https://area-publish.area-webar.workers.dev",
    PUBLISH_KEY: "",
    VIEWER_BASE: "https://area-viewer.pages.dev"
  };
</script>

  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
      "qrcode": "https://esm.sh/qrcode@1.5.3"
    }
  }
  </script>

<script>
/* Original-GLB Passthrough für Publish */
(function(){
  const AREA = (window.__AREA = window.__AREA || {});
  AREA.__origGlb = null;
  const fileGlbInput = document.getElementById('file-glb');
  if (fileGlbInput) {
    fileGlbInput.addEventListener('change', async (ev)=>{
      try{
        const f = ev.target.files && ev.target.files[0];
        if (!f) return;
        AREA.__origGlb = await f.arrayBuffer();
        console.log('[editor] Original GLB gepuffert (Datei):', f.name, AREA.__origGlb.byteLength, 'Bytes');
      }catch(e){ console.warn('[editor] GLB-Puffer fehlgeschlagen:', e); }
    });
  }
  AREA.rememberOriginalGlbFromUrl = async function(glbUrl){
    try{
      if (!/^https?:\/\//i.test(glbUrl)) return;
      const r = await fetch(glbUrl, { mode:'cors', credentials:'omit' });
      if (!r.ok){ console.warn('[editor] GLB-URL fetch fehlgeschlagen:', r.status, r.statusText); return; }
      AREA.__origGlb = await r.arrayBuffer();
      console.log('[editor] Original GLB gepuffert (URL):', glbUrl, AREA.__origGlb.byteLength, 'Bytes');
    }catch(e){ console.warn('[editor] GLB-URL Puffer fehlgeschlagen:', e); }
  };
  window.hasAnimationsInGlbBlob = async function(blob){
    try{
      const ab = await blob.arrayBuffer();
      const dv = new DataView(ab);
      if (dv.getUint32(0, true) !== 0x46546c67) return false;
      if (dv.getUint32(4, true) < 2) return false;
      const jsonLength = dv.getUint32(12, true);
      const jsonType   = dv.getUint32(16, true);
      if (jsonType !== 0x4E4F534A) return false;
      const jsonStr = new TextDecoder().decode(new Uint8Array(ab, 20, jsonLength));
      try {
        const j = JSON.parse(jsonStr);
        return Array.isArray(j.animations) && j.animations.length > 0;
      } catch {
        return /"animations"\s*:\s*\[/.test(jsonStr);
      }
    }catch(e){
      console.warn('[editor] hasAnimationsInGlbBlob failed:', e);
      return false;
    }
  };
  const _origFetch = window.fetch.bind(window);
  window.fetch = async (input, init)=>{
    if (!init) init = {};
    const method = init.method ? String(init.method).toUpperCase() : 'GET';
    if (method !== 'POST') return _origFetch(input, init);
    if (!(init.body instanceof FormData)) return _origFetch(input, init);
    if (!AREA.__origGlb) return _origFetch(input, init);
    try{
      let urlString = '';
      if (typeof input === 'string') urlString = input;
      else if (input && typeof input.url === 'string') urlString = input.url;
      else return _origFetch(input, init);
      const urlObj = new URL(urlString, location.href);
      if (urlObj.pathname !== '/publish') return _origFetch(input, init);

      const fdOld = init.body;
      const fdNew = new FormData();
      let exporterSceneGlb = null;
      for (const [k,v] of fdOld.entries()){
        if (k === 'file' && v && typeof v.name === 'string' && /scene\.glb$/i.test(v.name||'')){
          exporterSceneGlb = v;
          continue;
        }
        fdNew.append(k,v);
      }
      let chosenGlb;
      if (!exporterSceneGlb){
        chosenGlb = new Blob([AREA.__origGlb], { type:'model/gltf-binary' });
        console.log('[editor] Publish: Original scene.glb angehängt (', AREA.__origGlb.byteLength, 'Bytes )');
      } else {
        const hasAnim = await window.hasAnimationsInGlbBlob(exporterSceneGlb);
        if (hasAnim){
          chosenGlb = exporterSceneGlb;
          console.log('[editor] Publish: Exporter-GLB mit animations[] verwendet.');
        } else {
          chosenGlb = new Blob([AREA.__origGlb], { type:'model/gltf-binary' });
          console.log('[editor] Exportiertes GLB ohne animations[] – fallback auf Original-GLB.');
        }
      }
      fdNew.append('file', chosenGlb, 'scene.glb');
      init = { ...init, body: fdNew };
    }catch(e){
      console.warn('[editor] fetch wrapper warn:', e);
      return _origFetch(input, init);
    }
    return _origFetch(input, init);
  };
  try {
    const btnClear = document.getElementById('btn-clear');
    btnClear && btnClear.addEventListener('click', ()=>{ AREA.__origGlb = null; });
    const btnNew = document.getElementById('btn-new');
    btnNew && btnNew.addEventListener('click', ()=>{ AREA.__origGlb = null; });
  }catch(_){}
})();
</script>

<script>
/* scene.json Export / buildSceneJson (mit Patch für loop/repeats) */
(function(){
  const AREA = (window.__AREA = window.__AREA || {});
  AREA.scene = AREA.scene || {};

  function val(sel, def=''){ const el=document.querySelector(sel); return (el && 'value' in el) ? (el.value ?? def) : def; }
  function chk(sel, def=false){ const el=document.querySelector(sel); return (el && 'checked' in el) ? !!el.checked : def; }
  function num(sel, def){ const v = parseFloat(val(sel, String(def))); return Number.isFinite(v) ? v : def; }
  function file(sel){ return (document.querySelector(sel)?.files?.[0]) || null; }

  function knownClipsCount(){
    try {
      if (Array.isArray(AREA.currentClips)) return AREA.currentClips.length;
      if (Array.isArray(AREA.scene?.clips)) return AREA.scene.clips.length;
    } catch {}
    return undefined;
  }

  window.buildSceneJson = function buildSceneJson(){
    const s  = (AREA.scene = AREA.scene || {});
    const a  = (s.animation = s.animation || {});
    const au = (s.audio = s.audio || {});
    const ui = (s.ui = s.ui || {});
    const wl = (ui.welcome = ui.welcome || {});

    a.clipName   = (val('#animClip', '*') || '*').trim();
    a.start      = (val('#animStart', 'onPlace') || 'onPlace');

    /* === PATCH (Mini-Fix) für loop & iterations === */
    const loopVal = document.getElementById('animLoop')?.value || 'repeat';
    a.loop       = (loopVal === 'repeat');
    a.iterations = Math.max(1, parseInt(document.getElementById('animRepeats')?.value || '9999', 10));

    au.autoplay  = val('#audioAutoplay', 'withAnimation') || 'withAnimation';
    au.loop      = (document.querySelector('#audioLoop') ? chk('#audioLoop', true) : true);
    au.volume    = Math.max(0, Math.min(1, document.querySelector('#audioVolume') ? num('#audioVolume', 0.85) : 0.85));

    wl.eyebrow   = val('#svEyebrow', '');
    wl.title     = val('#svTitle',  (s.meta?.title || 'ARea Scene'));
    wl.desc      = val('#svDesc',   'Tippe auf OK und platziere das 3D‑Objekt.');
    wl.nativeCta = val('#nativeCta', 'ios-only') || 'ios-only';

    const posterF = file('#file-poster');
    const audioF  = file('#file-audio');
    const usdzF   = file('#fileUsdz');

    s.meta = s.meta || {};
    s.meta.title = wl.title;
    s.meta.description = wl.desc;
    s.meta.mode = 'area-viewer';

    s.model = s.model || {};
    s.model.url = 'scene.glb';
    if (usdzF) s.model.usdzUrl = 'model.usdz';
    s.model.scale = (typeof s.model.scale === 'number') ? s.model.scale : 1.0;

    if (posterF) wl.poster = posterF.name;
    if (audioF)  au.url    = audioF.name;

    s.animation = a;
    s.audio = au;
    s.ui = ui;

    return JSON.parse(JSON.stringify(s));
  };

  if (typeof buildViewerEntryForMode !== 'function') {
    window.buildViewerEntryForMode = function(mode){
      const map = {
        'surface-webxr':      '/surface-ar/webxr.html',
        'native':             '/surface-ar/index.html',
        'image':              '/image-ar/viewer.html',
        'scene-viewer':       '/scene-viewer/index.html',
        'surface-guided':     '/surface-ar/guided.html',
        'surface-area-viewer':'/surface-ar/area-viewer.html'
      };
      return map[mode] || '/surface-ar/area-viewer.html';
    };
  }

  if (typeof buildRobustViewerUrl !== 'function') {
    window.buildRobustViewerUrl = function({ mode, sceneId, workerOrigin, viewerBase }){
      const entry = buildViewerEntryForMode(mode);
      const u = new URL(entry, viewerBase);
      const glbUrl = `${workerOrigin}/scenes/${encodeURIComponent(sceneId)}/scene.glb`;
      u.searchParams.set('glb', glbUrl);
      u.searchParams.set('scene', sceneId);
      u.searchParams.set('base', workerOrigin);
      if (mode === 'native') u.searchParams.set('force','native');
      return u.toString();
    };
  }

  try {
    const btn = document.getElementById('btn-publish');
    btn && btn.addEventListener('click', (ev)=>{ ev.preventDefault(); window.publishScene?.(); });
  }catch(_){}
})();
</script>

<script>
/* Anchor-abhängige UI (gekürzt) */
(function(){
  function byId(id){ return document.getElementById(id); }
  const sel     = byId('anchorMode');
  const svBlock = byId('svBlock');
  const usdzRow = byId('usdzUploadRow');
  const avAudio = byId('avAudioRow');

  function norm(v){ return String(v||'').trim().toLowerCase(); }
  function show(el,disp){ if(!el)return; el.hidden=false; el.style.display=disp; }
  function hide(el){ if(!el)return; el.style.display='none'; }

  function computeModes(){
    const v = norm(sel?.value);
    const txt = norm(sel?.options?.[sel.selectedIndex]?.textContent);
    const both = v + ' ' + txt;
    const isSceneViewer = v==='scene-viewer' || txt.includes('scene viewer') || txt.includes('szene viewer');
    const isAreaViewer  = v==='surface-area-viewer' || v==='area-viewer' || v==='surface-area' || both.includes('area-viewer') || both.includes('area viewer');
    const isGuided      = v==='surface-guided' || txt.includes('guided');
    return { isSceneViewer, isAreaViewer, isGuided, raw:v, label:txt };
  }
  function apply(reason=''){
    const { isSceneViewer, isAreaViewer } = computeModes();
    if (svBlock) (isSceneViewer || isAreaViewer) ? show(svBlock,'block') : hide(svBlock);
    if (usdzRow) isSceneViewer ? show(usdzRow,'') : hide(usdzRow);
    /* ... weitere UI-Regeln ... */
  }
  sel?.addEventListener('change',()=>apply('change'));
  apply('init');
})();
</script>

<!-- ===================================================================== -->
<!-- === PATCH BLÖCKE (Drop-In) ========================================= -->
<!-- ===================================================================== -->

<script type="module">
/* === FINAL WIRING: Projekt-Menü, Buttons, Theme-Toggle, Three-Sync === */
(() => {
  const $ = s => document.querySelector(s);

  // Projekt-Menü (öffnet nach unten) + Outside-Click
  const menu = $('#projectMenu');
  const btn  = $('#btn-project-menu');
  function toggleMenu(e){ e?.preventDefault(); menu?.classList.toggle('open'); btn?.setAttribute('aria-expanded', String(menu?.classList.contains('open'))); }
  btn?.addEventListener('click', toggleMenu);
  document.addEventListener('click', (e)=>{ if(menu && btn && !menu.contains(e.target) && e.target!==btn){ menu.classList.remove('open'); btn.setAttribute('aria-expanded','false'); } });

  // Menü-Buttons
  $('#btn-new')?.addEventListener('click', ()=>{ 
    if (confirm('Neues Projekt starten? Nicht gespeicherte Änderungen gehen verloren.')) { 
      document.getElementById('btn-clear')?.click(); 
      (window.setProjectName||(()=>{}))('Unbenanntes Projekt'); 
    }
  });
  $('#file-project')?.addEventListener('change', (ev)=>{
    const f = ev.target.files?.[0];
    ev.target.value = '';
    if (f) (window.importProjectFile||(()=>{}))(f);
  });
  $('#btn-save')?.addEventListener('click', ()=> (window.saveProject||(()=>{}))());
  $('#btn-save-as')?.addEventListener('click', ()=> (window.saveProject||(()=>{}))({saveAs:true}));
  $('#btn-preview')?.addEventListener('click', ()=> (window.previewModules||(()=>{}))());
  $('#btn-preview-draft')?.addEventListener('click', ()=> (window.previewDraft||(()=>{}))());

  // Theme-Toggle (3-Wege) inkl. Persistenz + Three-Sync
  const radios = ['th-slate','th-aurora','th-nebula'].map(id=>document.getElementById(id));
  function applyTheme(theme){
    const html = document.documentElement;
    ['theme-slate','theme-aurora','theme-nebula'].forEach(c=>html.classList.remove(c));
    html.classList.add(theme);
    try { localStorage.setItem('theme', theme); } catch {}
    try { window.__applyThemeToThree?.(); } catch {}
    const idx = { 'theme-slate':0, 'theme-aurora':1, 'theme-nebula':2 }[theme] ?? 0;
    radios[idx] && (radios[idx].checked = true);
  }
  radios.forEach(r => r?.addEventListener('change', ()=> applyTheme(r.value)));

  (function syncInitialTheme(){
    const html = document.documentElement;
    const cur = ['theme-nebula','theme-aurora','theme-slate'].find(c=>html.classList.contains(c)) || 'theme-nebula';
    applyTheme(cur);
  })();

  // Taste "T" = Theme zyklisch wechseln (nur wenn Fokus nicht in Eingabe)
  window.addEventListener('keydown', (e)=>{
    if (e.key.toLowerCase() !== 't') return;
    const el = document.activeElement;
    const tag = (el?.tagName || '').toLowerCase();
    if (el?.isContentEditable || ['input','textarea','select'].includes(tag)) return;
    const order = ['theme-slate','theme-aurora','theme-nebula'];
    const curIndex = order.findIndex(c=>document.documentElement.classList.contains(c));
    applyTheme(order[(curIndex+1) % order.length]);
  });

  requestAnimationFrame(()=> window.__applyThemeToThree?.());
})();
</script>

<script type="module">
/* === previewDraft(): schnelle Vorschau via data:URL (ohne Upload) === */
async function previewDraft(){
  try{
    const mode = document.getElementById('anchorMode')?.value || 'surface-webxr';
    const viewerBase = (window.__AREA || {}).VIEWER_BASE || 'https://area-viewer.pages.dev';
    const entryMap = {
      'surface-webxr':'/surface-ar/webxr.html',
      'native':'/surface-ar/index.html',
      'image':'/image-ar/viewer.html',
      'scene-viewer':'/scene-viewer/index.html',
      'surface-guided':'/surface-ar/guided.html',
      'surface-area-viewer':'/surface-ar/area-viewer.html'
    };
    const entry = entryMap[mode] || '/surface-ar/area-viewer.html';

    const data = await (window.buildProjectData||(()=>({})))();
    const src  = 'data:application/json;charset=utf-8,' + encodeURIComponent(JSON.stringify(data));
    let url = `${viewerBase}${entry}?src=${encodeURIComponent(src)}&anchor=${encodeURIComponent(mode)}`;

    const target = (document.getElementById('imageTargetUrl')?.value || '').trim();
    if (mode === 'image' && target) url += `&target=${encodeURIComponent(target)}`;

    const glb  = (document.getElementById('nativeGlbUrl')?.value || '').trim();
    const usdz = (document.getElementById('nativeUsdzUrl')?.value || '').trim();
    if (mode === 'native'){
      if (glb)  url += `&glb=${encodeURIComponent(glb)}`;
      if (usdz) url += `&usdz=${encodeURIComponent(usdz)}`;
    }

    window.open(url, '_blank', 'noopener');
    (window.toast||console.log)('Schnell-Preview geöffnet');
  }catch(e){
    console.warn(e);
    (window.toast||console.warn)('Preview fehlgeschlagen');
  }
}
window.previewDraft = previewDraft;
</script>

<script type="module">
/* Optionaler Publish-Patch: Modusabhängige JSON-Auswahl */
(() => {
  if (typeof window.publishScene === 'function'){
    const orig = window.publishScene;
    window.publishScene = async function(...args){
      const mode = document.getElementById('anchorMode')?.value || 'surface-webxr';
      const sceneJson = (mode === 'scene-viewer' || mode === 'surface-area-viewer')
        ? (window.buildSceneViewerJSON_CF?.() || window.buildSceneJson())
        : window.buildSceneJson();
      // Temporär buildSceneJson überschreiben falls Original intern erneut aufruft
      const backup = window.buildSceneJson;
      window.buildSceneJson = () => sceneJson;
      try {
        return await orig.apply(this, args);
      } finally {
        window.buildSceneJson = backup;
      }
    };
  }
})();
</script>


<style id="patch-minstage">
/* --- ARea Editor Runtime Patch: guard zero-sized stage/viewport --- */
#stage { min-width: 320px; min-height: 240px; }
#viewport { min-width: 320px; min-height: 240px; }
canvas { display:block; }
</style>

  <!-- Minimal Config -->
<script>
  window.__AREA = {
    PUBLISH_ENDPOINT: "https://area-publish-proxy.area-webar.workers.dev/publish",
    FILE_BASE:       "https://area-publish.area-webar.workers.dev",
    PUBLISH_KEY: "",
    VIEWER_BASE: "https://area-viewer.pages.dev"
  };
</script>

  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
      "qrcode": "https://esm.sh/qrcode@1.5.3"
    }
  }
  </script>

<script>
/* Original-GLB Passthrough für Publish */
(function(){
  const AREA = (window.__AREA = window.__AREA || {});
  AREA.__origGlb = null;
  const fileGlbInput = document.getElementById('file-glb');
  if (fileGlbInput) {
    fileGlbInput.addEventListener('change', async (ev)=>{
      try{
        const f = ev.target.files && ev.target.files[0];
        if (!f) return;
        AREA.__origGlb = await f.arrayBuffer();
        console.log('[editor] Original GLB gepuffert (Datei):', f.name, AREA.__origGlb.byteLength, 'Bytes');
      }catch(e){ console.warn('[editor] GLB-Puffer fehlgeschlagen:', e); }
    });
  }
  AREA.rememberOriginalGlbFromUrl = async function(glbUrl){
    try{
      if (!/^https?:\/\//i.test(glbUrl)) return;
      const r = await fetch(glbUrl, { mode:'cors', credentials:'omit' });
      if (!r.ok){ console.warn('[editor] GLB-URL fetch fehlgeschlagen:', r.status, r.statusText); return; }
      AREA.__origGlb = await r.arrayBuffer();
      console.log('[editor] Original GLB gepuffert (URL):', glbUrl, AREA.__origGlb.byteLength, 'Bytes');
    }catch(e){ console.warn('[editor] GLB-URL Puffer fehlgeschlagen:', e); }
  };
  window.hasAnimationsInGlbBlob = async function(blob){
    try{
      const ab = await blob.arrayBuffer();
      const dv = new DataView(ab);
      if (dv.getUint32(0, true) !== 0x46546c67) return false;
      if (dv.getUint32(4, true) < 2) return false;
      const jsonLength = dv.getUint32(12, true);
      const jsonType   = dv.getUint32(16, true);
      if (jsonType !== 0x4E4F534A) return false;
      const jsonStr = new TextDecoder().decode(new Uint8Array(ab, 20, jsonLength));
      try {
        const j = JSON.parse(jsonStr);
        return Array.isArray(j.animations) && j.animations.length > 0;
      } catch {
        return /"animations"\s*:\s*\[/.test(jsonStr);
      }
    }catch(e){
      console.warn('[editor] hasAnimationsInGlbBlob failed:', e);
      return false;
    }
  };
  const _origFetch = window.fetch.bind(window);
  window.fetch = async (input, init)=>{
    if (!init) init = {};
    const method = init.method ? String(init.method).toUpperCase() : 'GET';
    if (method !== 'POST') return _origFetch(input, init);
    if (!(init.body instanceof FormData)) return _origFetch(input, init);
    if (!AREA.__origGlb) return _origFetch(input, init);
    try{
      let urlString = '';
      if (typeof input === 'string') urlString = input;
      else if (input && typeof input.url === 'string') urlString = input.url;
      else return _origFetch(input, init);
      const urlObj = new URL(urlString, location.href);
      if (urlObj.pathname !== '/publish') return _origFetch(input, init);

      const fdOld = init.body;
      const fdNew = new FormData();
      let exporterSceneGlb = null;
      for (const [k,v] of fdOld.entries()){
        if (k === 'file' && v && typeof v.name === 'string' && /scene\.glb$/i.test(v.name||'')){
          exporterSceneGlb = v;
          continue;
        }
        fdNew.append(k,v);
      }
      let chosenGlb;
      if (!exporterSceneGlb){
        chosenGlb = new Blob([AREA.__origGlb], { type:'model/gltf-binary' });
        console.log('[editor] Publish: Original scene.glb angehängt (', AREA.__origGlb.byteLength, 'Bytes )');
      } else {
        const hasAnim = await window.hasAnimationsInGlbBlob(exporterSceneGlb);
        if (hasAnim){
          chosenGlb = exporterSceneGlb;
          console.log('[editor] Publish: Exporter-GLB mit animations[] verwendet.');
        } else {
          chosenGlb = new Blob([AREA.__origGlb], { type:'model/gltf-binary' });
          console.log('[editor] Exportiertes GLB ohne animations[] – fallback auf Original-GLB.');
        }
      }
      fdNew.append('file', chosenGlb, 'scene.glb');
      init = { ...init, body: fdNew };
    }catch(e){
      console.warn('[editor] fetch wrapper warn:', e);
      return _origFetch(input, init);
    }
    return _origFetch(input, init);
  };
  try {
    const btnClear = document.getElementById('btn-clear');
    btnClear && btnClear.addEventListener('click', ()=>{ AREA.__origGlb = null; });
    const btnNew = document.getElementById('btn-new');
    btnNew && btnNew.addEventListener('click', ()=>{ AREA.__origGlb = null; });
  }catch(_){}
})();
</script>

<script>
/* scene.json Export / buildSceneJson (mit Patch für loop/repeats) */
(function(){
  const AREA = (window.__AREA = window.__AREA || {});
  AREA.scene = AREA.scene || {};

  function val(sel, def=''){ const el=document.querySelector(sel); return (el && 'value' in el) ? (el.value ?? def) : def; }
  function chk(sel, def=false){ const el=document.querySelector(sel); return (el && 'checked' in el) ? !!el.checked : def; }
  function num(sel, def){ const v = parseFloat(val(sel, String(def))); return Number.isFinite(v) ? v : def; }
  function file(sel){ return (document.querySelector(sel)?.files?.[0]) || null; }

  function knownClipsCount(){
    try {
      if (Array.isArray(AREA.currentClips)) return AREA.currentClips.length;
      if (Array.isArray(AREA.scene?.clips)) return AREA.scene.clips.length;
    } catch {}
    return undefined;
  }

  window.buildSceneJson = function buildSceneJson(){
    const s  = (AREA.scene = AREA.scene || {});
    const a  = (s.animation = s.animation || {});
    const au = (s.audio = s.audio || {});
    const ui = (s.ui = s.ui || {});
    const wl = (ui.welcome = ui.welcome || {});

    a.clipName   = (val('#animClip', '*') || '*').trim();
    a.start      = (val('#animStart', 'onPlace') || 'onPlace');

    /* === PATCH (Mini-Fix) für loop & iterations === */
    const loopVal = document.getElementById('animLoop')?.value || 'repeat';
    a.loop       = (loopVal === 'repeat');
    a.iterations = Math.max(1, parseInt(document.getElementById('animRepeats')?.value || '9999', 10));

    au.autoplay  = val('#audioAutoplay', 'withAnimation') || 'withAnimation';
    au.loop      = (document.querySelector('#audioLoop') ? chk('#audioLoop', true) : true);
    au.volume    = Math.max(0, Math.min(1, document.querySelector('#audioVolume') ? num('#audioVolume', 0.85) : 0.85));

    wl.eyebrow   = val('#svEyebrow', '');
    wl.title     = val('#svTitle',  (s.meta?.title || 'ARea Scene'));
    wl.desc      = val('#svDesc',   'Tippe auf OK und platziere das 3D‑Objekt.');
    wl.nativeCta = val('#nativeCta', 'ios-only') || 'ios-only';

    const posterF = file('#file-poster');
    const audioF  = file('#file-audio');
    const usdzF   = file('#fileUsdz');

    s.meta = s.meta || {};
    s.meta.title = wl.title;
    s.meta.description = wl.desc;
    s.meta.mode = 'area-viewer';

    s.model = s.model || {};
    s.model.url = 'scene.glb';
    if (usdzF) s.model.usdzUrl = 'model.usdz';
    s.model.scale = (typeof s.model.scale === 'number') ? s.model.scale : 1.0;

    if (posterF) wl.poster = posterF.name;
    if (audioF)  au.url    = audioF.name;

    s.animation = a;
    s.audio = au;
    s.ui = ui;

    return JSON.parse(JSON.stringify(s));
  };

  if (typeof buildViewerEntryForMode !== 'function') {
    window.buildViewerEntryForMode = function(mode){
      const map = {
        'surface-webxr':      '/surface-ar/webxr.html',
        'native':             '/surface-ar/index.html',
        'image':              '/image-ar/viewer.html',
        'scene-viewer':       '/scene-viewer/index.html',
        'surface-guided':     '/surface-ar/guided.html',
        'surface-area-viewer':'/surface-ar/area-viewer.html'
      };
      return map[mode] || '/surface-ar/area-viewer.html';
    };
  }

  if (typeof buildRobustViewerUrl !== 'function') {
    window.buildRobustViewerUrl = function({ mode, sceneId, workerOrigin, viewerBase }){
      const entry = buildViewerEntryForMode(mode);
      const u = new URL(entry, viewerBase);
      const glbUrl = `${workerOrigin}/scenes/${encodeURIComponent(sceneId)}/scene.glb`;
      u.searchParams.set('glb', glbUrl);
      u.searchParams.set('scene', sceneId);
      u.searchParams.set('base', workerOrigin);
      if (mode === 'native') u.searchParams.set('force','native');
      return u.toString();
    };
  }

  try {
    const btn = document.getElementById('btn-publish');
    btn && btn.addEventListener('click', (ev)=>{ ev.preventDefault(); window.publishScene?.(); });
  }catch(_){}
})();
</script>

<script>
/* Anchor-abhängige UI (gekürzt) */
(function(){
  function byId(id){ return document.getElementById(id); }
  const sel     = byId('anchorMode');
  const svBlock = byId('svBlock');
  const usdzRow = byId('usdzUploadRow');
  const avAudio = byId('avAudioRow');

  function norm(v){ return String(v||'').trim().toLowerCase(); }
  function show(el,disp){ if(!el)return; el.hidden=false; el.style.display=disp; }
  function hide(el){ if(!el)return; el.style.display='none'; }

  function computeModes(){
    const v = norm(sel?.value);
    const txt = norm(sel?.options?.[sel.selectedIndex]?.textContent);
    const both = v + ' ' + txt;
    const isSceneViewer = v==='scene-viewer' || txt.includes('scene viewer') || txt.includes('szene viewer');
    const isAreaViewer  = v==='surface-area-viewer' || v==='area-viewer' || v==='surface-area' || both.includes('area-viewer') || both.includes('area viewer');
    const isGuided      = v==='surface-guided' || txt.includes('guided');
    return { isSceneViewer, isAreaViewer, isGuided, raw:v, label:txt };
  }
  function apply(reason=''){
    const { isSceneViewer, isAreaViewer } = computeModes();
    if (svBlock) (isSceneViewer || isAreaViewer) ? show(svBlock,'block') : hide(svBlock);
    if (usdzRow) isSceneViewer ? show(usdzRow,'') : hide(usdzRow);
    /* ... weitere UI-Regeln ... */
  }
  sel?.addEventListener('change',()=>apply('change'));
  apply('init');
})();
</script>

<!-- ===================================================================== -->
<!-- === PATCH BLÖCKE (Drop-In) ========================================= -->
<!-- ===================================================================== -->

<script type="module">
/* === FINAL WIRING: Projekt-Menü, Buttons, Theme-Toggle, Three-Sync === */
(() => {
  const $ = s => document.querySelector(s);

  // Projekt-Menü (öffnet nach unten) + Outside-Click
  const menu = $('#projectMenu');
  const btn  = $('#btn-project-menu');
  function toggleMenu(e){ e?.preventDefault(); menu?.classList.toggle('open'); btn?.setAttribute('aria-expanded', String(menu?.classList.contains('open'))); }
  btn?.addEventListener('click', toggleMenu);
  document.addEventListener('click', (e)=>{ if(menu && btn && !menu.contains(e.target) && e.target!==btn){ menu.classList.remove('open'); btn.setAttribute('aria-expanded','false'); } });

  // Menü-Buttons
  $('#btn-new')?.addEventListener('click', ()=>{ 
    if (confirm('Neues Projekt starten? Nicht gespeicherte Änderungen gehen verloren.')) { 
      document.getElementById('btn-clear')?.click(); 
      (window.setProjectName||(()=>{}))('Unbenanntes Projekt'); 
    }
  });
  $('#file-project')?.addEventListener('change', (ev)=>{
    const f = ev.target.files?.[0];
    ev.target.value = '';
    if (f) (window.importProjectFile||(()=>{}))(f);
  });
  $('#btn-save')?.addEventListener('click', ()=> (window.saveProject||(()=>{}))());
  $('#btn-save-as')?.addEventListener('click', ()=> (window.saveProject||(()=>{}))({saveAs:true}));
  $('#btn-preview')?.addEventListener('click', ()=> (window.previewModules||(()=>{}))());
  $('#btn-preview-draft')?.addEventListener('click', ()=> (window.previewDraft||(()=>{}))());

  // Theme-Toggle (3-Wege) inkl. Persistenz + Three-Sync
  const radios = ['th-slate','th-aurora','th-nebula'].map(id=>document.getElementById(id));
  function applyTheme(theme){
    const html = document.documentElement;
    ['theme-slate','theme-aurora','theme-nebula'].forEach(c=>html.classList.remove(c));
    html.classList.add(theme);
    try { localStorage.setItem('theme', theme); } catch {}
    try { window.__applyThemeToThree?.(); } catch {}
    const idx = { 'theme-slate':0, 'theme-aurora':1, 'theme-nebula':2 }[theme] ?? 0;
    radios[idx] && (radios[idx].checked = true);
  }
  radios.forEach(r => r?.addEventListener('change', ()=> applyTheme(r.value)));

  (function syncInitialTheme(){
    const html = document.documentElement;
    const cur = ['theme-nebula','theme-aurora','theme-slate'].find(c=>html.classList.contains(c)) || 'theme-nebula';
    applyTheme(cur);
  })();

  // Taste "T" = Theme zyklisch wechseln (nur wenn Fokus nicht in Eingabe)
  window.addEventListener('keydown', (e)=>{
    if (e.key.toLowerCase() !== 't') return;
    const el = document.activeElement;
    const tag = (el?.tagName || '').toLowerCase();
    if (el?.isContentEditable || ['input','textarea','select'].includes(tag)) return;
    const order = ['theme-slate','theme-aurora','theme-nebula'];
    const curIndex = order.findIndex(c=>document.documentElement.classList.contains(c));
    applyTheme(order[(curIndex+1) % order.length]);
  });

  requestAnimationFrame(()=> window.__applyThemeToThree?.());
})();
</script>

<script type="module">
/* Optionaler Publish-Patch: Modusabhängige JSON-Auswahl */
(() => {
  if (typeof window.publishScene === 'function'){
    const orig = window.publishScene;
    window.publishScene = async function(...args){
      const mode = document.getElementById('anchorMode')?.value || 'surface-webxr';
      const sceneJson = (mode === 'scene-viewer' || mode === 'surface-area-viewer')
        ? (window.buildSceneViewerJSON_CF?.() || window.buildSceneJson())
        : window.buildSceneJson();
      // Temporär buildSceneJson überschreiben falls Original intern erneut aufruft
      const backup = window.buildSceneJson;
      window.buildSceneJson = () => sceneJson;
      try {
        return await orig.apply(this, args);
      } finally {
        window.buildSceneJson = backup;
      }
    };
  }
})();
</script>


<style id="patch-minstage">
/* --- ARea Editor Runtime Patch: guard zero-sized stage/viewport --- */
#stage { min-width: 320px; min-height: 240px; }
#viewport { min-width: 320px; min-height: 240px; }
canvas { display:block; }
</style>

  <!-- Minimal Config -->
<script>
  window.__AREA = {
    PUBLISH_ENDPOINT: "https://area-publish-proxy.area-webar.workers.dev/publish",
    FILE_BASE:       "https://area-publish.area-webar.workers.dev",
    PUBLISH_KEY: "",
    VIEWER_BASE: "https://area-viewer.pages.dev"
  };
</script>

  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
      "qrcode": "https://esm.sh/qrcode@1.5.3"
    }
  }
  </script>

<script>
/* Original-GLB Passthrough für Publish */
(function(){
  const AREA = (window.__AREA = window.__AREA || {});
  AREA.__origGlb = null;
  const fileGlbInput = document.getElementById('file-glb');
  if (fileGlbInput) {
    fileGlbInput.addEventListener('change', async (ev)=>{
      try{
        const f = ev.target.files && ev.target.files[0];
        if (!f) return;
        AREA.__origGlb = await f.arrayBuffer();
        console.log('[editor] Original GLB gepuffert (Datei):', f.name, AREA.__origGlb.byteLength, 'Bytes');
      }catch(e){ console.warn('[editor] GLB-Puffer fehlgeschlagen:', e); }
    });
  }
  AREA.rememberOriginalGlbFromUrl = async function(glbUrl){
    try{
      if (!/^https?:\/\//i.test(glbUrl)) return;
      const r = await fetch(glbUrl, { mode:'cors', credentials:'omit' });
      if (!r.ok){ console.warn('[editor] GLB-URL fetch fehlgeschlagen:', r.status, r.statusText); return; }
      AREA.__origGlb = await r.arrayBuffer();
      console.log('[editor] Original GLB gepuffert (URL):', glbUrl, AREA.__origGlb.byteLength, 'Bytes');
    }catch(e){ console.warn('[editor] GLB-URL Puffer fehlgeschlagen:', e); }
  };
  window.hasAnimationsInGlbBlob = async function(blob){
    try{
      const ab = await blob.arrayBuffer();
      const dv = new DataView(ab);
      if (dv.getUint32(0, true) !== 0x46546c67) return false;
      if (dv.getUint32(4, true) < 2) return false;
      const jsonLength = dv.getUint32(12, true);
      const jsonType   = dv.getUint32(16, true);
      if (jsonType !== 0x4E4F534A) return false;
      const jsonStr = new TextDecoder().decode(new Uint8Array(ab, 20, jsonLength));
      try {
        const j = JSON.parse(jsonStr);
        return Array.isArray(j.animations) && j.animations.length > 0;
      } catch {
        return /"animations"\s*:\s*\[/.test(jsonStr);
      }
    }catch(e){
      console.warn('[editor] hasAnimationsInGlbBlob failed:', e);
      return false;
    }
  };
  const _origFetch = window.fetch.bind(window);
  window.fetch = async (input, init)=>{
    if (!init) init = {};
    const method = init.method ? String(init.method).toUpperCase() : 'GET';
    if (method !== 'POST') return _origFetch(input, init);
    if (!(init.body instanceof FormData)) return _origFetch(input, init);
    if (!AREA.__origGlb) return _origFetch(input, init);
    try{
      let urlString = '';
      if (typeof input === 'string') urlString = input;
      else if (input && typeof input.url === 'string') urlString = input.url;
      else return _origFetch(input, init);
      const urlObj = new URL(urlString, location.href);
      if (urlObj.pathname !== '/publish') return _origFetch(input, init);

      const fdOld = init.body;
      const fdNew = new FormData();
      let exporterSceneGlb = null;
      for (const [k,v] of fdOld.entries()){
        if (k === 'file' && v && typeof v.name === 'string' && /scene\.glb$/i.test(v.name||'')){
          exporterSceneGlb = v;
          continue;
        }
        fdNew.append(k,v);
      }
      let chosenGlb;
      if (!exporterSceneGlb){
        chosenGlb = new Blob([AREA.__origGlb], { type:'model/gltf-binary' });
        console.log('[editor] Publish: Original scene.glb angehängt (', AREA.__origGlb.byteLength, 'Bytes )');
      } else {
        const hasAnim = await window.hasAnimationsInGlbBlob(exporterSceneGlb);
        if (hasAnim){
          chosenGlb = exporterSceneGlb;
          console.log('[editor] Publish: Exporter-GLB mit animations[] verwendet.');
        } else {
          chosenGlb = new Blob([AREA.__origGlb], { type:'model/gltf-binary' });
          console.log('[editor] Exportiertes GLB ohne animations[] – fallback auf Original-GLB.');
        }
      }
      fdNew.append('file', chosenGlb, 'scene.glb');
      init = { ...init, body: fdNew };
    }catch(e){
      console.warn('[editor] fetch wrapper warn:', e);
      return _origFetch(input, init);
    }
    return _origFetch(input, init);
  };
  try {
    const btnClear = document.getElementById('btn-clear');
    btnClear && btnClear.addEventListener('click', ()=>{ AREA.__origGlb = null; });
    const btnNew = document.getElementById('btn-new');
    btnNew && btnNew.addEventListener('click', ()=>{ AREA.__origGlb = null; });
  }catch(_){}
})();
</script>

<script>
/* scene.json Export / buildSceneJson (mit Patch für loop/repeats) */
(function(){
  const AREA = (window.__AREA = window.__AREA || {});
  AREA.scene = AREA.scene || {};

  function val(sel, def=''){ const el=document.querySelector(sel); return (el && 'value' in el) ? (el.value ?? def) : def; }
  function chk(sel, def=false){ const el=document.querySelector(sel); return (el && 'checked' in el) ? !!el.checked : def; }
  function num(sel, def){ const v = parseFloat(val(sel, String(def))); return Number.isFinite(v) ? v : def; }
  function file(sel){ return (document.querySelector(sel)?.files?.[0]) || null; }

  function knownClipsCount(){
    try {
      if (Array.isArray(AREA.currentClips)) return AREA.currentClips.length;
      if (Array.isArray(AREA.scene?.clips)) return AREA.scene.clips.length;
    } catch {}
    return undefined;
  }

  window.buildSceneJson = function buildSceneJson(){
    const s  = (AREA.scene = AREA.scene || {});
    const a  = (s.animation = s.animation || {});
    const au = (s.audio = s.audio || {});
    const ui = (s.ui = s.ui || {});
    const wl = (ui.welcome = ui.welcome || {});

    a.clipName   = (val('#animClip', '*') || '*').trim();
    a.start      = (val('#animStart', 'onPlace') || 'onPlace');

    /* === PATCH (Mini-Fix) für loop & iterations === */
    const loopVal = document.getElementById('animLoop')?.value || 'repeat';
    a.loop       = (loopVal === 'repeat');
    a.iterations = Math.max(1, parseInt(document.getElementById('animRepeats')?.value || '9999', 10));

    au.autoplay  = val('#audioAutoplay', 'withAnimation') || 'withAnimation';
    au.loop      = (document.querySelector('#audioLoop') ? chk('#audioLoop', true) : true);
    au.volume    = Math.max(0, Math.min(1, document.querySelector('#audioVolume') ? num('#audioVolume', 0.85) : 0.85));

    wl.eyebrow   = val('#svEyebrow', '');
    wl.title     = val('#svTitle',  (s.meta?.title || 'ARea Scene'));
    wl.desc      = val('#svDesc',   'Tippe auf OK und platziere das 3D‑Objekt.');
    wl.nativeCta = val('#nativeCta', 'ios-only') || 'ios-only';

    const posterF = file('#file-poster');
    const audioF  = file('#file-audio');
    const usdzF   = file('#fileUsdz');

    s.meta = s.meta || {};
    s.meta.title = wl.title;
    s.meta.description = wl.desc;
    s.meta.mode = 'area-viewer';

    s.model = s.model || {};
    s.model.url = 'scene.glb';
    if (usdzF) s.model.usdzUrl = 'model.usdz';
    s.model.scale = (typeof s.model.scale === 'number') ? s.model.scale : 1.0;

    if (posterF) wl.poster = posterF.name;
    if (audioF)  au.url    = audioF.name;

    s.animation = a;
    s.audio = au;
    s.ui = ui;

    return JSON.parse(JSON.stringify(s));
  };

  if (typeof buildViewerEntryForMode !== 'function') {
    window.buildViewerEntryForMode = function(mode){
      const map = {
        'surface-webxr':      '/surface-ar/webxr.html',
        'native':             '/surface-ar/index.html',
        'image':              '/image-ar/viewer.html',
        'scene-viewer':       '/scene-viewer/index.html',
        'surface-guided':     '/surface-ar/guided.html',
        'surface-area-viewer':'/surface-ar/area-viewer.html'
      };
      return map[mode] || '/surface-ar/area-viewer.html';
    };
  }

  if (typeof buildRobustViewerUrl !== 'function') {
    window.buildRobustViewerUrl = function({ mode, sceneId, workerOrigin, viewerBase }){
      const entry = buildViewerEntryForMode(mode);
      const u = new URL(entry, viewerBase);
      const glbUrl = `${workerOrigin}/scenes/${encodeURIComponent(sceneId)}/scene.glb`;
      u.searchParams.set('glb', glbUrl);
      u.searchParams.set('scene', sceneId);
      u.searchParams.set('base', workerOrigin);
      if (mode === 'native') u.searchParams.set('force','native');
      return u.toString();
    };
  }

  try {
    const btn = document.getElementById('btn-publish');
    btn && btn.addEventListener('click', (ev)=>{ ev.preventDefault(); window.publishScene?.(); });
  }catch(_){}
})();
</script>

<script>
/* Anchor-abhängige UI (gekürzt) */
(function(){
  function byId(id){ return document.getElementById(id); }
  const sel     = byId('anchorMode');
  const svBlock = byId('svBlock');
  const usdzRow = byId('usdzUploadRow');
  const avAudio = byId('avAudioRow');

  function norm(v){ return String(v||'').trim().toLowerCase(); }
  function show(el,disp){ if(!el)return; el.hidden=false; el.style.display=disp; }
  function hide(el){ if(!el)return; el.style.display='none'; }

  function computeModes(){
    const v = norm(sel?.value);
    const txt = norm(sel?.options?.[sel.selectedIndex]?.textContent);
    const both = v + ' ' + txt;
    const isSceneViewer = v==='scene-viewer' || txt.includes('scene viewer') || txt.includes('szene viewer');
    const isAreaViewer  = v==='surface-area-viewer' || v==='area-viewer' || v==='surface-area' || both.includes('area-viewer') || both.includes('area viewer');
    const isGuided      = v==='surface-guided' || txt.includes('guided');
    return { isSceneViewer, isAreaViewer, isGuided, raw:v, label:txt };
  }
  function apply(reason=''){
    const { isSceneViewer, isAreaViewer } = computeModes();
    if (svBlock) (isSceneViewer || isAreaViewer) ? show(svBlock,'block') : hide(svBlock);
    if (usdzRow) isSceneViewer ? show(usdzRow,'') : hide(usdzRow);
    /* ... weitere UI-Regeln ... */
  }
  sel?.addEventListener('change',()=>apply('change'));
  apply('init');
})();
</script>

<!-- ===================================================================== -->
<!-- === PATCH BLÖCKE (Drop-In) ========================================= -->
<!-- ===================================================================== -->

<script type="module">
/* === FINAL WIRING: Projekt-Menü, Buttons, Theme-Toggle, Three-Sync === */
(() => {
  const $ = s => document.querySelector(s);

  // Projekt-Menü (öffnet nach unten) + Outside-Click
  const menu = $('#projectMenu');
  const btn  = $('#btn-project-menu');
  function toggleMenu(e){ e?.preventDefault(); menu?.classList.toggle('open'); btn?.setAttribute('aria-expanded', String(menu?.classList.contains('open'))); }
  btn?.addEventListener('click', toggleMenu);
  document.addEventListener('click', (e)=>{ if(menu && btn && !menu.contains(e.target) && e.target!==btn){ menu.classList.remove('open'); btn.setAttribute('aria-expanded','false'); } });

  // Menü-Buttons
  $('#btn-new')?.addEventListener('click', ()=>{ 
    if (confirm('Neues Projekt starten? Nicht gespeicherte Änderungen gehen verloren.')) { 
      document.getElementById('btn-clear')?.click(); 
      (window.setProjectName||(()=>{}))('Unbenanntes Projekt'); 
    }
  });
  $('#file-project')?.addEventListener('change', (ev)=>{
    const f = ev.target.files?.[0];
    ev.target.value = '';
    if (f) (window.importProjectFile||(()=>{}))(f);
  });
  $('#btn-save')?.addEventListener('click', ()=> (window.saveProject||(()=>{}))());
  $('#btn-save-as')?.addEventListener('click', ()=> (window.saveProject||(()=>{}))({saveAs:true}));
  $('#btn-preview')?.addEventListener('click', ()=> (window.previewModules||(()=>{}))());
  $('#btn-preview-draft')?.addEventListener('click', ()=> (window.previewDraft||(()=>{}))());

  // Theme-Toggle (3-Wege) inkl. Persistenz + Three-Sync
  const radios = ['th-slate','th-aurora','th-nebula'].map(id=>document.getElementById(id));
  function applyTheme(theme){
    const html = document.documentElement;
    ['theme-slate','theme-aurora','theme-nebula'].forEach(c=>html.classList.remove(c));
    html.classList.add(theme);
    try { localStorage.setItem('theme', theme); } catch {}
    try { window.__applyThemeToThree?.(); } catch {}
    const idx = { 'theme-slate':0, 'theme-aurora':1, 'theme-nebula':2 }[theme] ?? 0;
    radios[idx] && (radios[idx].checked = true);
  }
  radios.forEach(r => r?.addEventListener('change', ()=> applyTheme(r.value)));

  (function syncInitialTheme(){
    const html = document.documentElement;
    const cur = ['theme-nebula','theme-aurora','theme-slate'].find(c=>html.classList.contains(c)) || 'theme-nebula';
    applyTheme(cur);
  })();

  // Taste "T" = Theme zyklisch wechseln (nur wenn Fokus nicht in Eingabe)
  window.addEventListener('keydown', (e)=>{
    if (e.key.toLowerCase() !== 't') return;
    const el = document.activeElement;
    const tag = (el?.tagName || '').toLowerCase();
    if (el?.isContentEditable || ['input','textarea','select'].includes(tag)) return;
    const order = ['theme-slate','theme-aurora','theme-nebula'];
    const curIndex = order.findIndex(c=>document.documentElement.classList.contains(c));
    applyTheme(order[(curIndex+1) % order.length]);
  });

  requestAnimationFrame(()=> window.__applyThemeToThree?.());
})();
</script>

<script type="module">
/* Optionaler Publish-Patch: Modusabhängige JSON-Auswahl */
(() => {
  if (typeof window.publishScene === 'function'){
    const orig = window.publishScene;
    window.publishScene = async function(...args){
      const mode = document.getElementById('anchorMode')?.value || 'surface-webxr';
      const sceneJson = (mode === 'scene-viewer' || mode === 'surface-area-viewer')
        ? (window.buildSceneViewerJSON_CF?.() || window.buildSceneJson())
        : window.buildSceneJson();
      // Temporär buildSceneJson überschreiben falls Original intern erneut aufruft
      const backup = window.buildSceneJson;
      window.buildSceneJson = () => sceneJson;
      try {
        return await orig.apply(this, args);
      } finally {
        window.buildSceneJson = backup;
      }
    };
  }
})();
</script>


<style id="patch-minstage">
/* --- ARea Editor Runtime Patch: guard zero-sized stage/viewport --- */
#stage { min-width: 320px; min-height: 240px; }
#viewport { min-width: 320px; min-height: 240px; }
canvas { display:block; }
</style>

  <!-- Minimal Config -->
<script>
  window.__AREA = {
    PUBLISH_ENDPOINT: "https://area-publish-proxy.area-webar.workers.dev/publish",
    FILE_BASE:       "https://area-publish.area-webar.workers.dev",
    PUBLISH_KEY: "",
    VIEWER_BASE: "https://area-viewer.pages.dev"
  };
</script>

  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
      "qrcode": "https://esm.sh/qrcode@1.5.3"
    }
  }
  </script>

<script>
/* Original-GLB Passthrough für Publish */
(function(){
  const AREA = (window.__AREA = window.__AREA || {});
  AREA.__origGlb = null;
  const fileGlbInput = document.getElementById('file-glb');
  if (fileGlbInput) {
    fileGlbInput.addEventListener('change', async (ev)=>{
      try{
        const f = ev.target.files && ev.target.files[0];
        if (!f) return;
        AREA.__origGlb = await f.arrayBuffer();
        console.log('[editor] Original GLB gepuffert (Datei):', f.name, AREA.__origGlb.byteLength, 'Bytes');
      }catch(e){ console.warn('[editor] GLB-Puffer fehlgeschlagen:', e); }
    });
  }
  AREA.rememberOriginalGlbFromUrl = async function(glbUrl){
    try{
      if (!/^https?:\/\//i.test(glbUrl)) return;
      const r = await fetch(glbUrl, { mode:'cors', credentials:'omit' });
      if (!r.ok){ console.warn('[editor] GLB-URL fetch fehlgeschlagen:', r.status, r.statusText); return; }
      AREA.__origGlb = await r.arrayBuffer();
      console.log('[editor] Original GLB gepuffert (URL):', glbUrl, AREA.__origGlb.byteLength, 'Bytes');
    }catch(e){ console.warn('[editor] GLB-URL Puffer fehlgeschlagen:', e); }
  };
  window.hasAnimationsInGlbBlob = async function(blob){
    try{
      const ab = await blob.arrayBuffer();
      const dv = new DataView(ab);
      if (dv.getUint32(0, true) !== 0x46546c67) return false;
      if (dv.getUint32(4, true) < 2) return false;
      const jsonLength = dv.getUint32(12, true);
      const jsonType   = dv.getUint32(16, true);
      if (jsonType !== 0x4E4F534A) return false;
      const jsonStr = new TextDecoder().decode(new Uint8Array(ab, 20, jsonLength));
      try {
        const j = JSON.parse(jsonStr);
        return Array.isArray(j.animations) && j.animations.length > 0;
      } catch {
        return /"animations"\s*:\s*\[/.test(jsonStr);
      }
    }catch(e){
      console.warn('[editor] hasAnimationsInGlbBlob failed:', e);
      return false;
    }
  };
  const _origFetch = window.fetch.bind(window);
  window.fetch = async (input, init)=>{
    if (!init) init = {};
    const method = init.method ? String(init.method).toUpperCase() : 'GET';
    if (method !== 'POST') return _origFetch(input, init);
    if (!(init.body instanceof FormData)) return _origFetch(input, init);
    if (!AREA.__origGlb) return _origFetch(input, init);
    try{
      let urlString = '';
      if (typeof input === 'string') urlString = input;
      else if (input && typeof input.url === 'string') urlString = input.url;
      else return _origFetch(input, init);
      const urlObj = new URL(urlString, location.href);
      if (urlObj.pathname !== '/publish') return _origFetch(input, init);

      const fdOld = init.body;
      const fdNew = new FormData();
      let exporterSceneGlb = null;
      for (const [k,v] of fdOld.entries()){
        if (k === 'file' && v && typeof v.name === 'string' && /scene\.glb$/i.test(v.name||'')){
          exporterSceneGlb = v;
          continue;
        }
        fdNew.append(k,v);
      }
      let chosenGlb;
      if (!exporterSceneGlb){
        chosenGlb = new Blob([AREA.__origGlb], { type:'model/gltf-binary' });
        console.log('[editor] Publish: Original scene.glb angehängt (', AREA.__origGlb.byteLength, 'Bytes )');
      } else {
        const hasAnim = await window.hasAnimationsInGlbBlob(exporterSceneGlb);
        if (hasAnim){
          chosenGlb = exporterSceneGlb;
          console.log('[editor] Publish: Exporter-GLB mit animations[] verwendet.');
        } else {
          chosenGlb = new Blob([AREA.__origGlb], { type:'model/gltf-binary' });
          console.log('[editor] Exportiertes GLB ohne animations[] – fallback auf Original-GLB.');
        }
      }
      fdNew.append('file', chosenGlb, 'scene.glb');
      init = { ...init, body: fdNew };
    }catch(e){
      console.warn('[editor] fetch wrapper warn:', e);
      return _origFetch(input, init);
    }
    return _origFetch(input, init);
  };
  try {
    const btnClear = document.getElementById('btn-clear');
    btnClear && btnClear.addEventListener('click', ()=>{ AREA.__origGlb = null; });
    const btnNew = document.getElementById('btn-new');
    btnNew && btnNew.addEventListener('click', ()=>{ AREA.__origGlb = null; });
  }catch(_){}
})();
</script>

<script>
/* scene.json Export / buildSceneJson (mit Patch für loop/repeats) */
(function(){
  const AREA = (window.__AREA = window.__AREA || {});
  AREA.scene = AREA.scene || {};

  function val(sel, def=''){ const el=document.querySelector(sel); return (el && 'value' in el) ? (el.value ?? def) : def; }
  function chk(sel, def=false){ const el=document.querySelector(sel); return (el && 'checked' in el) ? !!el.checked : def; }
  function num(sel, def){ const v = parseFloat(val(sel, String(def))); return Number.isFinite(v) ? v : def; }
  function file(sel){ return (document.querySelector(sel)?.files?.[0]) || null; }

  function knownClipsCount(){
    try {
      if (Array.isArray(AREA.currentClips)) return AREA.currentClips.length;
      if (Array.isArray(AREA.scene?.clips)) return AREA.scene.clips.length;
    } catch {}
    return undefined;
  }

  window.buildSceneJson = function buildSceneJson(){
    const s  = (AREA.scene = AREA.scene || {});
    const a  = (s.animation = s.animation || {});
    const au = (s.audio = s.audio || {});
    const ui = (s.ui = s.ui || {});
    const wl = (ui.welcome = ui.welcome || {});

    a.clipName   = (val('#animClip', '*') || '*').trim();
    a.start      = (val('#animStart', 'onPlace') || 'onPlace');

    /* === PATCH (Mini-Fix) für loop & iterations === */
    const loopVal = document.getElementById('animLoop')?.value || 'repeat';
    a.loop       = (loopVal === 'repeat');
    a.iterations = Math.max(1, parseInt(document.getElementById('animRepeats')?.value || '9999', 10));

    au.autoplay  = val('#audioAutoplay', 'withAnimation') || 'withAnimation';
    au.loop      = (document.querySelector('#audioLoop') ? chk('#audioLoop', true) : true);
    au.volume    = Math.max(0, Math.min(1, document.querySelector('#audioVolume') ? num('#audioVolume', 0.85) : 0.85));

    wl.eyebrow   = val('#svEyebrow', '');
    wl.title     = val('#svTitle',  (s.meta?.title || 'ARea Scene'));
    wl.desc      = val('#svDesc',   'Tippe auf OK und platziere das 3D‑Objekt.');
    wl.nativeCta = val('#nativeCta', 'ios-only') || 'ios-only';

    const posterF = file('#file-poster');
    const audioF  = file('#file-audio');
    const usdzF   = file('#fileUsdz');

    s.meta = s.meta || {};
    s.meta.title = wl.title;
    s.meta.description = wl.desc;
    s.meta.mode = 'area-viewer';

    s.model = s.model || {};
    s.model.url = 'scene.glb';
    if (usdzF) s.model.usdzUrl = 'model.usdz';
    s.model.scale = (typeof s.model.scale === 'number') ? s.model.scale : 1.0;

    if (posterF) wl.poster = posterF.name;
    if (audioF)  au.url    = audioF.name;

    s.animation = a;
    s.audio = au;
    s.ui = ui;

    return JSON.parse(JSON.stringify(s));
  };

  if (typeof buildViewerEntryForMode !== 'function') {
    window.buildViewerEntryForMode = function(mode){
      const map = {
        'surface-webxr':      '/surface-ar/webxr.html',
        'native':             '/surface-ar/index.html',
        'image':              '/image-ar/viewer.html',
        'scene-viewer':       '/scene-viewer/index.html',
        'surface-guided':     '/surface-ar/guided.html',
        'surface-area-viewer':'/surface-ar/area-viewer.html'
      };
      return map[mode] || '/surface-ar/area-viewer.html';
    };
  }

  if (typeof buildRobustViewerUrl !== 'function') {
    window.buildRobustViewerUrl = function({ mode, sceneId, workerOrigin, viewerBase }){
      const entry = buildViewerEntryForMode(mode);
      const u = new URL(entry, viewerBase);
      const glbUrl = `${workerOrigin}/scenes/${encodeURIComponent(sceneId)}/scene.glb`;
      u.searchParams.set('glb', glbUrl);
      u.searchParams.set('scene', sceneId);
      u.searchParams.set('base', workerOrigin);
      if (mode === 'native') u.searchParams.set('force','native');
      return u.toString();
    };
  }

  try {
    const btn = document.getElementById('btn-publish');
    btn && btn.addEventListener('click', (ev)=>{ ev.preventDefault(); window.publishScene?.(); });
  }catch(_){}
})();
</script>

<script>
/* Anchor-abhängige UI (gekürzt) */
(function(){
  function byId(id){ return document.getElementById(id); }
  const sel     = byId('anchorMode');
  const svBlock = byId('svBlock');
  const usdzRow = byId('usdzUploadRow');
  const avAudio = byId('avAudioRow');

  function norm(v){ return String(v||'').trim().toLowerCase(); }
  function show(el,disp){ if(!el)return; el.hidden=false; el.style.display=disp; }
  function hide(el){ if(!el)return; el.style.display='none'; }

  function computeModes(){
    const v = norm(sel?.value);
    const txt = norm(sel?.options?.[sel.selectedIndex]?.textContent);
    const both = v + ' ' + txt;
    const isSceneViewer = v==='scene-viewer' || txt.includes('scene viewer') || txt.includes('szene viewer');
    const isAreaViewer  = v==='surface-area-viewer' || v==='area-viewer' || v==='surface-area' || both.includes('area-viewer') || both.includes('area viewer');
    const isGuided      = v==='surface-guided' || txt.includes('guided');
    return { isSceneViewer, isAreaViewer, isGuided, raw:v, label:txt };
  }
  function apply(reason=''){
    const { isSceneViewer, isAreaViewer } = computeModes();
    if (svBlock) (isSceneViewer || isAreaViewer) ? show(svBlock,'block') : hide(svBlock);
    if (usdzRow) isSceneViewer ? show(usdzRow,'') : hide(usdzRow);
    /* ... weitere UI-Regeln ... */
  }
  sel?.addEventListener('change',()=>apply('change'));
  apply('init');
})();
</script>

<!-- ===================================================================== -->
<!-- === PATCH BLÖCKE (Drop-In) ========================================= -->
<!-- ===================================================================== -->

<script type="module">
/* === FINAL WIRING: Projekt-Menü, Buttons, Theme-Toggle, Three-Sync === */
(() => {
  const $ = s => document.querySelector(s);

  // Projekt-Menü (öffnet nach unten) + Outside-Click
  const menu = $('#projectMenu');
  const btn  = $('#btn-project-menu');
  function toggleMenu(e){ e?.preventDefault(); menu?.classList.toggle('open'); btn?.setAttribute('aria-expanded', String(menu?.classList.contains('open'))); }
  btn?.addEventListener('click', toggleMenu);
  document.addEventListener('click', (e)=>{ if(menu && btn && !menu.contains(e.target) && e.target!==btn){ menu.classList.remove('open'); btn.setAttribute('aria-expanded','false'); } });

  // Menü-Buttons
  $('#btn-new')?.addEventListener('click', ()=>{ 
    if (confirm('Neues Projekt starten? Nicht gespeicherte Änderungen gehen verloren.')) { 
      document.getElementById('btn-clear')?.click(); 
      (window.setProjectName||(()=>{}))('Unbenanntes Projekt'); 
    }
  });
  $('#file-project')?.addEventListener('change', (ev)=>{
    const f = ev.target.files?.[0];
    ev.target.value = '';
    if (f) (window.importProjectFile||(()=>{}))(f);
  });
  $('#btn-save')?.addEventListener('click', ()=> (window.saveProject||(()=>{}))());
  $('#btn-save-as')?.addEventListener('click', ()=> (window.saveProject||(()=>{}))({saveAs:true}));
  $('#btn-preview')?.addEventListener('click', ()=> (window.previewModules||(()=>{}))());
  $('#btn-preview-draft')?.addEventListener('click', ()=> (window.previewDraft||(()=>{}))());

  // Theme-Toggle (3-Wege) inkl. Persistenz + Three-Sync
  const radios = ['th-slate','th-aurora','th-nebula'].map(id=>document.getElementById(id));
  function applyTheme(theme){
    const html = document.documentElement;
    ['theme-slate','theme-aurora','theme-nebula'].forEach(c=>html.classList.remove(c));
    html.classList.add(theme);
    try { localStorage.setItem('theme', theme); } catch {}
    try { window.__applyThemeToThree?.(); } catch {}
    const idx = { 'theme-slate':0, 'theme-aurora':1, 'theme-nebula':2 }[theme] ?? 0;
    radios[idx] && (radios[idx].checked = true);
  }
  radios.forEach(r => r?.addEventListener('change', ()=> applyTheme(r.value)));

  (function syncInitialTheme(){
    const html = document.documentElement;
    const cur = ['theme-nebula','theme-aurora','theme-slate'].find(c=>html.classList.contains(c)) || 'theme-nebula';
    applyTheme(cur);
  })();

  // Taste "T" = Theme zyklisch wechseln (nur wenn Fokus nicht in Eingabe)
  window.addEventListener('keydown', (e)=>{
    if (e.key.toLowerCase() !== 't') return;
    const el = document.activeElement;
    const tag = (el?.tagName || '').toLowerCase();
    if (el?.isContentEditable || ['input','textarea','select'].includes(tag)) return;
    const order = ['theme-slate','theme-aurora','theme-nebula'];
    const curIndex = order.findIndex(c=>document.documentElement.classList.contains(c));
    applyTheme(order[(curIndex+1) % order.length]);
  });

  requestAnimationFrame(()=> window.__applyThemeToThree?.());
})();
</script>

<script type="module">
/* Optionaler Publish-Patch: Modusabhängige JSON-Auswahl */
(() => {
  if (typeof window.publishScene === 'function'){
    const orig = window.publishScene;
    window.publishScene = async function(...args){
      const mode = document.getElementById('anchorMode')?.value || 'surface-webxr';
      const sceneJson = (mode === 'scene-viewer' || mode === 'surface-area-viewer')
        ? (window.buildSceneViewerJSON_CF?.() || window.buildSceneJson())
        : window.buildSceneJson();
      // Temporär buildSceneJson überschreiben falls Original intern erneut aufruft
      const backup = window.buildSceneJson;
      window.buildSceneJson = () => sceneJson;
      try {
        return await orig.apply(this, args);
      } finally {
        window.buildSceneJson = backup;
      }
    };
  }
})();
</script>


<style id="patch-minstage">
/* --- ARea Editor Runtime Patch: guard zero-sized stage/viewport --- */
#stage { min-width: 320px; min-height: 240px; }
#viewport { min-width: 320px; min-height: 240px; }
canvas { display:block; }
</style>

  <!-- Minimal Config -->
<script>
  window.__AREA = {
    PUBLISH_ENDPOINT: "https://area-publish-proxy.area-webar.workers.dev/publish",
    FILE_BASE:       "https://area-publish.area-webar.workers.dev",
    PUBLISH_KEY: "",
    VIEWER_BASE: "https://area-viewer.pages.dev"
  };
</script>

  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
      "qrcode": "https://esm.sh/qrcode@1.5.3"
    }
  }
  </script>

<script>
/* Original-GLB Passthrough für Publish */
(function(){
  const AREA = (window.__AREA = window.__AREA || {});
  AREA.__origGlb = null;
  const fileGlbInput = document.getElementById('file-glb');
  if (fileGlbInput) {
    fileGlbInput.addEventListener('change', async (ev)=>{
      try{
        const f = ev.target.files && ev.target.files[0];
        if (!f) return;
        AREA.__origGlb = await f.arrayBuffer();
        console.log('[editor] Original GLB gepuffert (Datei):', f.name, AREA.__origGlb.byteLength, 'Bytes');
      }catch(e){ console.warn('[editor] GLB-Puffer fehlgeschlagen:', e); }
    });
  }
  AREA.rememberOriginalGlbFromUrl = async function(glbUrl){
    try{
      if (!/^https?:\/\//i.test(glbUrl)) return;
      const r = await fetch(glbUrl, { mode:'cors', credentials:'omit' });
      if (!r.ok){ console.warn('[editor] GLB-URL fetch fehlgeschlagen:', r.status, r.statusText); return; }
      AREA.__origGlb = await r.arrayBuffer();
      console.log('[editor] Original GLB gepuffert (URL):', glbUrl, AREA.__origGlb.byteLength, 'Bytes');
    }catch(e){ console.warn('[editor] GLB-URL Puffer fehlgeschlagen:', e); }
  };
  window.hasAnimationsInGlbBlob = async function(blob){
    try{
      const ab = await blob.arrayBuffer();
      const dv = new DataView(ab);
      if (dv.getUint32(0, true) !== 0x46546c67) return false;
      if (dv.getUint32(4, true) < 2) return false;
      const jsonLength = dv.getUint32(12, true);
      const jsonType   = dv.getUint32(16, true);
      if (jsonType !== 0x4E4F534A) return false;
      const jsonStr = new TextDecoder().decode(new Uint8Array(ab, 20, jsonLength));
      try {
        const j = JSON.parse(jsonStr);
        return Array.isArray(j.animations) && j.animations.length > 0;
      } catch {
        return /"animations"\s*:\s*\[/.test(jsonStr);
      }
    }catch(e){
      console.warn('[editor] hasAnimationsInGlbBlob failed:', e);
      return false;
    }
  };
  const _origFetch = window.fetch.bind(window);
  window.fetch = async (input, init)=>{
    if (!init) init = {};
    const method = init.method ? String(init.method).toUpperCase() : 'GET';
    if (method !== 'POST') return _origFetch(input, init);
    if (!(init.body instanceof FormData)) return _origFetch(input, init);
    if (!AREA.__origGlb) return _origFetch(input, init);
    try{
      let urlString = '';
      if (typeof input === 'string') urlString = input;
      else if (input && typeof input.url === 'string') urlString = input.url;
      else return _origFetch(input, init);
      const urlObj = new URL(urlString, location.href);
      if (urlObj.pathname !== '/publish') return _origFetch(input, init);

      const fdOld = init.body;
      const fdNew = new FormData();
      let exporterSceneGlb = null;
      for (const [k,v] of fdOld.entries()){
        if (k === 'file' && v && typeof v.name === 'string' && /scene\.glb$/i.test(v.name||'')){
          exporterSceneGlb = v;
          continue;
        }
        fdNew.append(k,v);
      }
      let chosenGlb;
      if (!exporterSceneGlb){
        chosenGlb = new Blob([AREA.__origGlb], { type:'model/gltf-binary' });
        console.log('[editor] Publish: Original scene.glb angehängt (', AREA.__origGlb.byteLength, 'Bytes )');
      } else {
        const hasAnim = await window.hasAnimationsInGlbBlob(exporterSceneGlb);
        if (hasAnim){
          chosenGlb = exporterSceneGlb;
          console.log('[editor] Publish: Exporter-GLB mit animations[] verwendet.');
        } else {
          chosenGlb = new Blob([AREA.__origGlb], { type:'model/gltf-binary' });
          console.log('[editor] Exportiertes GLB ohne animations[] – fallback auf Original-GLB.');
        }
      }
      fdNew.append('file', chosenGlb, 'scene.glb');
      init = { ...init, body: fdNew };
    }catch(e){
      console.warn('[editor] fetch wrapper warn:', e);
      return _origFetch(input, init);
    }
    return _origFetch(input, init);
  };
  try {
    const btnClear = document.getElementById('btn-clear');
    btnClear && btnClear.addEventListener('click', ()=>{ AREA.__origGlb = null; });
    const btnNew = document.getElementById('btn-new');
    btnNew && btnNew.addEventListener('click', ()=>{ AREA.__origGlb = null; });
  }catch(_){}
})();
</script>

<script>
/* scene.json Export / buildSceneJson (mit Patch für loop/repeats) */
(function(){
  const AREA = (window.__AREA = window.__AREA || {});
  AREA.scene = AREA.scene || {};

  function val(sel, def=''){ const el=document.querySelector(sel); return (el && 'value' in el) ? (el.value ?? def) : def; }
  function chk(sel, def=false){ const el=document.querySelector(sel); return (el && 'checked' in el) ? !!el.checked : def; }
  function num(sel, def){ const v = parseFloat(val(sel, String(def))); return Number.isFinite(v) ? v : def; }
  function file(sel){ return (document.querySelector(sel)?.files?.[0]) || null; }

  function knownClipsCount(){
    try {
      if (Array.isArray(AREA.currentClips)) return AREA.currentClips.length;
      if (Array.isArray(AREA.scene?.clips)) return AREA.scene.clips.length;
    } catch {}
    return undefined;
  }

  window.buildSceneJson = function buildSceneJson(){
    const s  = (AREA.scene = AREA.scene || {});
    const a  = (s.animation = s.animation || {});
    const au = (s.audio = s.audio || {});
    const ui = (s.ui = s.ui || {});
    const wl = (ui.welcome = ui.welcome || {});

    a.clipName   = (val('#animClip', '*') || '*').trim();
    a.start      = (val('#animStart', 'onPlace') || 'onPlace');

    /* === PATCH (Mini-Fix) für loop & iterations === */
    const loopVal = document.getElementById('animLoop')?.value || 'repeat';
    a.loop       = (loopVal === 'repeat');
    a.iterations = Math.max(1, parseInt(document.getElementById('animRepeats')?.value || '9999', 10));

    au.autoplay  = val('#audioAutoplay', 'withAnimation') || 'withAnimation';
    au.loop      = (document.querySelector('#audioLoop') ? chk('#audioLoop', true) : true);
    au.volume    = Math.max(0, Math.min(1, document.querySelector('#audioVolume') ? num('#audioVolume', 0.85) : 0.85));

    wl.eyebrow   = val('#svEyebrow', '');
    wl.title     = val('#svTitle',  (s.meta?.title || 'ARea Scene'));
    wl.desc      = val('#svDesc',   'Tippe auf OK und platziere das 3D‑Objekt.');
    wl.nativeCta = val('#nativeCta', 'ios-only') || 'ios-only';

    const posterF = file('#file-poster');
    const audioF  = file('#file-audio');
    const usdzF   = file('#fileUsdz');

    s.meta = s.meta || {};
    s.meta.title = wl.title;
    s.meta.description = wl.desc;
    s.meta.mode = 'area-viewer';

    s.model = s.model || {};
    s.model.url = 'scene.glb';
    if (usdzF) s.model.usdzUrl = 'model.usdz';
    s.model.scale = (typeof s.model.scale === 'number') ? s.model.scale : 1.0;

    if (posterF) wl.poster = posterF.name;
    if (audioF)  au.url    = audioF.name;

    s.animation = a;
    s.audio = au;
    s.ui = ui;

    return JSON.parse(JSON.stringify(s));
  };

  if (typeof buildViewerEntryForMode !== 'function') {
    window.buildViewerEntryForMode = function(mode){
      const map = {
        'surface-webxr':      '/surface-ar/webxr.html',
        'native':             '/surface-ar/index.html',
        'image':              '/image-ar/viewer.html',
        'scene-viewer':       '/scene-viewer/index.html',
        'surface-guided':     '/surface-ar/guided.html',
        'surface-area-viewer':'/surface-ar/area-viewer.html'
      };
      return map[mode] || '/surface-ar/area-viewer.html';
    };
  }

  if (typeof buildRobustViewerUrl !== 'function') {
    window.buildRobustViewerUrl = function({ mode, sceneId, workerOrigin, viewerBase }){
      const entry = buildViewerEntryForMode(mode);
      const u = new URL(entry, viewerBase);
      const glbUrl = `${workerOrigin}/scenes/${encodeURIComponent(sceneId)}/scene.glb`;
      u.searchParams.set('glb', glbUrl);
      u.searchParams.set('scene', sceneId);
      u.searchParams.set('base', workerOrigin);
      if (mode === 'native') u.searchParams.set('force','native');
      return u.toString();
    };
  }

  try {
    const btn = document.getElementById('btn-publish');
    btn && btn.addEventListener('click', (ev)=>{ ev.preventDefault(); window.publishScene?.(); });
  }catch(_){}
})();
</script>

<script>
/* Anchor-abhängige UI (gekürzt) */
(function(){
  function byId(id){ return document.getElementById(id); }
  const sel     = byId('anchorMode');
  const svBlock = byId('svBlock');
  const usdzRow = byId('usdzUploadRow');
  const avAudio = byId('avAudioRow');

  function norm(v){ return String(v||'').trim().toLowerCase(); }
  function show(el,disp){ if(!el)return; el.hidden=false; el.style.display=disp; }
  function hide(el){ if(!el)return; el.style.display='none'; }

  function computeModes(){
    const v = norm(sel?.value);
    const txt = norm(sel?.options?.[sel.selectedIndex]?.textContent);
    const both = v + ' ' + txt;
    const isSceneViewer = v==='scene-viewer' || txt.includes('scene viewer') || txt.includes('szene viewer');
    const isAreaViewer  = v==='surface-area-viewer' || v==='area-viewer' || v==='surface-area' || both.includes('area-viewer') || both.includes('area viewer');
    const isGuided      = v==='surface-guided' || txt.includes('guided');
    return { isSceneViewer, isAreaViewer, isGuided, raw:v, label:txt };
  }
  function apply(reason=''){
    const { isSceneViewer, isAreaViewer } = computeModes();
    if (svBlock) (isSceneViewer || isAreaViewer) ? show(svBlock,'block') : hide(svBlock);
    if (usdzRow) isSceneViewer ? show(usdzRow,'') : hide(usdzRow);
    /* ... weitere UI-Regeln ... */
  }
  sel?.addEventListener('change',()=>apply('change'));
  apply('init');
})();
</script>

<!-- ===================================================================== -->
<!-- === PATCH BLÖCKE (Drop-In) ========================================= -->
<!-- ===================================================================== -->

<script type="module">
/* === FINAL WIRING: Projekt-Menü, Buttons, Theme-Toggle, Three-Sync === */
(() => {
  const $ = s => document.querySelector(s);

  // Projekt-Menü (öffnet nach unten) + Outside-Click
  const menu = $('#projectMenu');
  const btn  = $('#btn-project-menu');
  function toggleMenu(e){ e?.preventDefault(); menu?.classList.toggle('open'); btn?.setAttribute('aria-expanded', String(menu?.classList.contains('open'))); }
  btn?.addEventListener('click', toggleMenu);
  document.addEventListener('click', (e)=>{ if(menu && btn && !menu.contains(e.target) && e.target!==btn){ menu.classList.remove('open'); btn.setAttribute('aria-expanded','false'); } });

  // Menü-Buttons
  $('#btn-new')?.addEventListener('click', ()=>{ 
    if (confirm('Neues Projekt starten? Nicht gespeicherte Änderungen gehen verloren.')) { 
      document.getElementById('btn-clear')?.click(); 
      (window.setProjectName||(()=>{}))('Unbenanntes Projekt'); 
    }
  });
  $('#file-project')?.addEventListener('change', (ev)=>{
    const f = ev.target.files?.[0];
    ev.target.value = '';
    if (f) (window.importProjectFile||(()=>{}))(f);
  });
  $('#btn-save')?.addEventListener('click', ()=> (window.saveProject||(()=>{}))());
  $('#btn-save-as')?.addEventListener('click', ()=> (window.saveProject||(()=>{}))({saveAs:true}));
  $('#btn-preview')?.addEventListener('click', ()=> (window.previewModules||(()=>{}))());
  $('#btn-preview-draft')?.addEventListener('click', ()=> (window.previewDraft||(()=>{}))());

  // Theme-Toggle (3-Wege) inkl. Persistenz + Three-Sync
  const radios = ['th-slate','th-aurora','th-nebula'].map(id=>document.getElementById(id));
  function applyTheme(theme){
    const html = document.documentElement;
    ['theme-slate','theme-aurora','theme-nebula'].forEach(c=>html.classList.remove(c));
    html.classList.add(theme);
    try { localStorage.setItem('theme', theme); } catch {}
    try { window.__applyThemeToThree?.(); } catch {}
    const idx = { 'theme-slate':0, 'theme-aurora':1, 'theme-nebula':2 }[theme] ?? 0;
    radios[idx] && (radios[idx].checked = true);
  }
  radios.forEach(r => r?.addEventListener('change', ()=> applyTheme(r.value)));

  (function syncInitialTheme(){
    const html = document.documentElement;
    const cur = ['theme-nebula','theme-aurora','theme-slate'].find(c=>html.classList.contains(c)) || 'theme-nebula';
    applyTheme(cur);
  })();

  // Taste "T" = Theme zyklisch wechseln (nur wenn Fokus nicht in Eingabe)
  window.addEventListener('keydown', (e)=>{
    if (e.key.toLowerCase() !== 't') return;
    const el = document.activeElement;
    const tag = (el?.tagName || '').toLowerCase();
    if (el?.isContentEditable || ['input','textarea','select'].includes(tag)) return;
    const order = ['theme-slate','theme-aurora','theme-nebula'];
    const curIndex = order.findIndex(c=>document.documentElement.classList.contains(c));
    applyTheme(order[(curIndex+1) % order.length]);
  });

  requestAnimationFrame(()=> window.__applyThemeToThree?.());
})();
</script>

<script type="module">
/* Optionaler Publish-Patch: Modusabhängige JSON-Auswahl */
(() => {
  if (typeof window.publishScene === 'function'){
    const orig = window.publishScene;
    window.publishScene = async function(...args){
      const mode = document.getElementById('anchorMode')?.value || 'surface-webxr';
      const sceneJson = (mode === 'scene-viewer' || mode === 'surface-area-viewer')
        ? (window.buildSceneViewerJSON_CF?.() || window.buildSceneJson())
        : window.buildSceneJson();
      // Temporär buildSceneJson überschreiben falls Original intern erneut aufruft
      const backup = window.buildSceneJson;
      window.buildSceneJson = () => sceneJson;
      try {
        return await orig.apply(this, args);
      } finally {
        window.buildSceneJson = backup;
      }
    };
  }
})();
</script>


<style id="patch-minstage">
/* --- ARea Editor Runtime Patch: guard zero-sized stage/viewport --- */
#stage { min-width: 320px; min-height: 240px; }
#viewport { min-width: 320px; min-height: 240px; }
canvas { display:block; }
</style>

  <!-- Minimal Config -->
<script>
  window.__AREA = {
    PUBLISH_ENDPOINT: "https://area-publish-proxy.area-webar.workers.dev/publish",
    FILE_BASE:       "https://area-publish.area-webar.workers.dev",
    PUBLISH_KEY: "",
    VIEWER_BASE: "https://area-viewer.pages.dev"
  };
</script>

  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
      "qrcode": "https://esm.sh/qrcode@1.5.3"
    }
  }
  </script>

<script>
/* Original-GLB Passthrough für Publish */
(function(){
  const AREA = (window.__AREA = window.__AREA || {});
  AREA.__origGlb = null;
  const fileGlbInput = document.getElementById('file-glb');
  if (fileGlbInput) {
    fileGlbInput.addEventListener('change', async (ev)=>{
      try{
        const f = ev.target.files && ev.target.files[0];
        if (!f) return;
        AREA.__origGlb = await f.arrayBuffer();
        console.log('[editor] Original GLB gepuffert (Datei):', f.name, AREA.__origGlb.byteLength, 'Bytes');
      }catch(e){ console.warn('[editor] GLB-Puffer fehlgeschlagen:', e); }
    });
  }
  AREA.rememberOriginalGlbFromUrl = async function(glbUrl){
    try{
      if (!/^https?:\/\//i.test(glbUrl)) return;
      const r = await fetch(glbUrl, { mode:'cors', credentials:'omit' });
      if (!r.ok){ console.warn('[editor] GLB-URL fetch fehlgeschlagen:', r.status, r.statusText); return; }
      AREA.__origGlb = await r.arrayBuffer();
      console.log('[editor] Original GLB gepuffert (URL):', glbUrl, AREA.__origGlb.byteLength, 'Bytes');
    }catch(e){ console.warn('[editor] GLB-URL Puffer fehlgeschlagen:', e); }
  };
  window.hasAnimationsInGlbBlob = async function(blob){
    try{
      const ab = await blob.arrayBuffer();
      const dv = new DataView(ab);
      if (dv.getUint32(0, true) !== 0x46546c67) return false;
      if (dv.getUint32(4, true) < 2) return false;
      const jsonLength = dv.getUint32(12, true);
      const jsonType   = dv.getUint32(16, true);
      if (jsonType !== 0x4E4F534A) return false;
      const jsonStr = new TextDecoder().decode(new Uint8Array(ab, 20, jsonLength));
      try {
        const j = JSON.parse(jsonStr);
        return Array.isArray(j.animations) && j.animations.length > 0;
      } catch {
        return /"animations"\s*:\s*\[/.test(jsonStr);
      }
    }catch(e){
      console.warn('[editor] hasAnimationsInGlbBlob failed:', e);
      return false;
    }
  };
  const _origFetch = window.fetch.bind(window);
  window.fetch = async (input, init)=>{
    if (!init) init = {};
    const method = init.method ? String(init.method).toUpperCase() : 'GET';
    if (method !== 'POST') return _origFetch(input, init);
    if (!(init.body instanceof FormData)) return _origFetch(input, init);
    if (!AREA.__origGlb) return _origFetch(input, init);
    try{
      let urlString = '';
      if (typeof input === 'string') urlString = input;
      else if (input && typeof input.url === 'string') urlString = input.url;
      else return _origFetch(input, init);
      const urlObj = new URL(urlString, location.href);
      if (urlObj.pathname !== '/publish') return _origFetch(input, init);

      const fdOld = init.body;
      const fdNew = new FormData();
      let exporterSceneGlb = null;
      for (const [k,v] of fdOld.entries()){
        if (k === 'file' && v && typeof v.name === 'string' && /scene\.glb$/i.test(v.name||'')){
          exporterSceneGlb = v;
          continue;
        }
        fdNew.append(k,v);
      }
      let chosenGlb;
      if (!exporterSceneGlb){
        chosenGlb = new Blob([AREA.__origGlb], { type:'model/gltf-binary' });
        console.log('[editor] Publish: Original scene.glb angehängt (', AREA.__origGlb.byteLength, 'Bytes )');
      } else {
        const hasAnim = await window.hasAnimationsInGlbBlob(exporterSceneGlb);
        if (hasAnim){
          chosenGlb = exporterSceneGlb;
          console.log('[editor] Publish: Exporter-GLB mit animations[] verwendet.');
        } else {
          chosenGlb = new Blob([AREA.__origGlb], { type:'model/gltf-binary' });
          console.log('[editor] Exportiertes GLB ohne animations[] – fallback auf Original-GLB.');
        }
      }
      fdNew.append('file', chosenGlb, 'scene.glb');
      init = { ...init, body: fdNew };
    }catch(e){
      console.warn('[editor] fetch wrapper warn:', e);
      return _origFetch(input, init);
    }
    return _origFetch(input, init);
  };
  try {
    const btnClear = document.getElementById('btn-clear');
    btnClear && btnClear.addEventListener('click', ()=>{ AREA.__origGlb = null; });
    const btnNew = document.getElementById('btn-new');
    btnNew && btnNew.addEventListener('click', ()=>{ AREA.__origGlb = null; });
  }catch(_){}
})();
</script>

<script>
/* scene.json Export / buildSceneJson (mit Patch für loop/repeats) */
(function(){
  const AREA = (window.__AREA = window.__AREA || {});
  AREA.scene = AREA.scene || {};

  function val(sel, def=''){ const el=document.querySelector(sel); return (el && 'value' in el) ? (el.value ?? def) : def; }
  function chk(sel, def=false){ const el=document.querySelector(sel); return (el && 'checked' in el) ? !!el.checked : def; }
  function num(sel, def){ const v = parseFloat(val(sel, String(def))); return Number.isFinite(v) ? v : def; }
  function file(sel){ return (document.querySelector(sel)?.files?.[0]) || null; }

  function knownClipsCount(){
    try {
      if (Array.isArray(AREA.currentClips)) return AREA.currentClips.length;
      if (Array.isArray(AREA.scene?.clips)) return AREA.scene.clips.length;
    } catch {}
    return undefined;
  }

  window.buildSceneJson = function buildSceneJson(){
    const s  = (AREA.scene = AREA.scene || {});
    const a  = (s.animation = s.animation || {});
    const au = (s.audio = s.audio || {});
    const ui = (s.ui = s.ui || {});
    const wl = (ui.welcome = ui.welcome || {});

    a.clipName   = (val('#animClip', '*') || '*').trim();
    a.start      = (val('#animStart', 'onPlace') || 'onPlace');

    /* === PATCH (Mini-Fix) für loop & iterations === */
    const loopVal = document.getElementById('animLoop')?.value || 'repeat';
    a.loop       = (loopVal === 'repeat');
    a.iterations = Math.max(1, parseInt(document.getElementById('animRepeats')?.value || '9999', 10));

    au.autoplay  = val('#audioAutoplay', 'withAnimation') || 'withAnimation';
    au.loop      = (document.querySelector('#audioLoop') ? chk('#audioLoop', true) : true);
    au.volume    = Math.max(0, Math.min(1, document.querySelector('#audioVolume') ? num('#audioVolume', 0.85) : 0.85));

    wl.eyebrow   = val('#svEyebrow', '');
    wl.title     = val('#svTitle',  (s.meta?.title || 'ARea Scene'));
    wl.desc      = val('#svDesc',   'Tippe auf OK und platziere das 3D‑Objekt.');
    wl.nativeCta = val('#nativeCta', 'ios-only') || 'ios-only';

    const posterF = file('#file-poster');
    const audioF  = file('#file-audio');
    const usdzF   = file('#fileUsdz');

    s.meta = s.meta || {};
    s.meta.title = wl.title;
    s.meta.description = wl.desc;
    s.meta.mode = 'area-viewer';

    s.model = s.model || {};
    s.model.url = 'scene.glb';
    if (usdzF) s.model.usdzUrl = 'model.usdz';
    s.model.scale = (typeof s.model.scale === 'number') ? s.model.scale : 1.0;

    if (posterF) wl.poster = posterF.name;
    if (audioF)  au.url    = audioF.name;

    s.animation = a;
    s.audio = au;
    s.ui = ui;

    return JSON.parse(JSON.stringify(s));
  };

  if (typeof buildViewerEntryForMode !== 'function') {
    window.buildViewerEntryForMode = function(mode){
      const map = {
        'surface-webxr':      '/surface-ar/webxr.html',
        'native':             '/surface-ar/index.html',
        'image':              '/image-ar/viewer.html',
        'scene-viewer':       '/scene-viewer/index.html',
        'surface-guided':     '/surface-ar/guided.html',
        'surface-area-viewer':'/surface-ar/area-viewer.html'
      };
      return map[mode] || '/surface-ar/area-viewer.html';
    };
  }

  if (typeof buildRobustViewerUrl !== 'function') {
    window.buildRobustViewerUrl = function({ mode, sceneId, workerOrigin, viewerBase }){
      const entry = buildViewerEntryForMode(mode);
      const u = new URL(entry, viewerBase);
      const glbUrl = `${workerOrigin}/scenes/${encodeURIComponent(sceneId)}/scene.glb`;
      u.searchParams.set('glb', glbUrl);
      u.searchParams.set('scene', sceneId);
      u.searchParams.set('base', workerOrigin);
      if (mode === 'native') u.searchParams.set('force','native');
      return u.toString();
    };
  }

  try {
    const btn = document.getElementById('btn-publish');
    btn && btn.addEventListener('click', (ev)=>{ ev.preventDefault(); window.publishScene?.(); });
  }catch(_){}
})();
</script>

<script>
/* Anchor-abhängige UI (gekürzt) */
(function(){
  function byId(id){ return document.getElementById(id); }
  const sel     = byId('anchorMode');
  const svBlock = byId('svBlock');
  const usdzRow = byId('usdzUploadRow');
  const avAudio = byId('avAudioRow');

  function norm(v){ return String(v||'').trim().toLowerCase(); }
  function show(el,disp){ if(!el)return; el.hidden=false; el.style.display=disp; }
  function hide(el){ if(!el)return; el.style.display='none'; }

  function computeModes(){
    const v = norm(sel?.value);
    const txt = norm(sel?.options?.[sel.selectedIndex]?.textContent);
    const both = v + ' ' + txt;
    const isSceneViewer = v==='scene-viewer' || txt.includes('scene viewer') || txt.includes('szene viewer');
    const isAreaViewer  = v==='surface-area-viewer' || v==='area-viewer' || v==='surface-area' || both.includes('area-viewer') || both.includes('area viewer');
    const isGuided      = v==='surface-guided' || txt.includes('guided');
    return { isSceneViewer, isAreaViewer, isGuided, raw:v, label:txt };
  }
  function apply(reason=''){
    const { isSceneViewer, isAreaViewer } = computeModes();
    if (svBlock) (isSceneViewer || isAreaViewer) ? show(svBlock,'block') : hide(svBlock);
    if (usdzRow) isSceneViewer ? show(usdzRow,'') : hide(usdzRow);
    /* ... weitere UI-Regeln ... */
  }
  sel?.addEventListener('change',()=>apply('change'));
  apply('init');
})();

/* === Audio-Helper: erstes Audioobjekt in der Szene finden === */
function findFirstAudio(){
  for (const rec of state.objects){
    const m = rec?.media;
    if (m && m.kind === 'audio'){
      // Wenn über "Medien import" als Datei geladen wurde, steckt die File im rec.file
      const fromFile = (rec.file && (
        /^audio\//.test(rec.file.type) || /\.(mp3|wav|ogg|m4a)$/i.test(rec.file.name)
      )) ? rec.file : null;

      // Quelle aus dem Media-Record (kann data: oder blob: sein)
      const src = (m.src || '').trim();
      const fromDataUrl = (!fromFile && src.startsWith('data:')) ? src : null;
      const fromBlobUrl = (!fromFile && src.startsWith('blob:')) ? src : null;

      return {
        loop: !!m.loop,
        fromFile,       // File | null
        fromDataUrl,    // string | null (data:)
        fromBlobUrl     // string | null (blob:)
      };
    }
  }
  return null;
}


function buildSceneJSON({ sceneId, title, mode, glbUrl, usdzUrl, targetUrl }) {
  const clipName  = getSelectedClipNameForExport() || "*";
  const audioInfo = findFirstAudio();

  const json = {
    meta: {
      version: "1.1",
      mode,
      title: title || sceneId,
      createdAt: new Date().toISOString()
    },
    model: { url: glbUrl, usdzUrl: usdzUrl || null, scale: 1, rotateY: 0 },
    animation: {
      enabled: true,
      clipName,
      start: (document.getElementById('animStartMode')?.value || 'onStart'),
      loop:  (document.getElementById('animLoop')?.value || 'repeat') === 'repeat',
      iterations: parseInt(document.getElementById('animRepeats')?.value || '9999', 10) || 9999,
      clampWhenFinished: true
    },
    ui: { showGround: true, autocenter: true, loader: "minimal" }
  };

  if (mode === "image") {
    json.target = { mindUrl: targetUrl || null };
  }

  if (audioInfo) {
    json.audio = {
      url: "audio.mp3",      // relativ
      autoplay: "onPlace",   // startet nach erstem Tap-to-place
      loop: !!audioInfo.loop,
      volume: 0.85
    };
  }

  return json;
}



    function val(id, def=''){ const el = document.getElementById(id); const v=(el?.value||'').trim(); return v || def; }

function buildSceneViewerJSON_CF() {
  const clipName = getSelectedClipNameForExport() || "*";
  const showPlay = !!document.getElementById('svShowPlayBtn')?.checked;
  const showMute = !!document.getElementById('svShowMuteBtn')?.checked;

  const eyebrow = document.getElementById('svEyebrow')?.value || "ARea – Szene";
  const title   = document.getElementById('svTitle')?.value   || projectName || "Scene";
  const desc    = document.getElementById('svDesc')?.value    || "Klicke auf OK, um zu starten.";

  const audioInfo = findFirstAudio(); // dein Helper

   return {
    ui: {
      showGround: true,
      autocenter: true,
      welcome: {
        eyebrow, title, desc, cta: "OK",
        poster: "poster.jpg",
        nativeCta: "ios-only"   // <- NEU: niemals auf Android zeigen
      },
      controls: { showPlay, showMute }
    },
    camera: { fov: 50, start:[2.2,1.6,3.0], lookAt:[0,1.1,0] },
    model:  { url: "scene.glb", scale: 1, rotateY: 0 }, // RELATIV
    animation: {
      enabled: true,
      clipName,
      start: (document.getElementById('animStartMode')?.value || 'onStart'),
      loop:  (document.getElementById('animLoop')?.value||'repeat') === 'repeat',
      iterations: parseInt(document.getElementById('animRepeats')?.value||'9999',10)||9999,
      clampWhenFinished: true,
      crossfade: 0.25,
      timeScale: 1
    },
    audio: audioInfo ? {
      // WICHTIG: NUR RELATIV!
      url: "audio.mp3",
      autoplay: "withAnimation",
      loop: !!audioInfo.loop,
      volume: 0.85
    } : { url: "" }
  };
}



    function showSharePanel(url){
      let el = document.getElementById('shareOverlay');
      if(el) el.remove();
      el = document.createElement('div'); el.id='shareOverlay';
      el.style.cssText='position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,.55);z-index:3000;';
      const card=document.createElement('div');
      card.style.cssText='background: var(--panel); border:1px solid var(--border); border-radius:14px; padding:16px; max-width:520px; width:92%; color:var(--text); box-shadow:0 10px 30px rgba(0,0,0,.4)';
      const h=document.createElement('div'); h.textContent='Veröffentlicht – teilen & scannen'; h.style.cssText='font-weight:800;margin-bottom:8px;color:var(--muted)';
      const qr=document.createElement('canvas'); qr.width=0; qr.height=0; qr.style.cssText='display:block;margin:8px auto;';
      const link=document.createElement('div'); link.textContent=url; link.style.cssText='font-size:12px;word-break:break-all;margin:8px 0;color:#aecdff;';
      const row=document.createElement('div'); row.style.cssText='display:flex;gap:8px;justify-content:flex-end;margin-top:10px;';
      const btnCopy=document.createElement('button'); btnCopy.className='btn'; btnCopy.textContent='Link kopieren';
      const btnOpen=document.createElement('button'); btnOpen.className='btn'; btnOpen.textContent='Im neuen Tab öffnen';
      const btnClose=document.createElement('button'); btnClose.className='btn'; btnClose.textContent='Schließen';
      row.append(btnCopy,btnOpen,btnClose);
      card.append(h,qr,link,row); el.append(card); document.body.append(el);
      QRCode.toCanvas(qr, url, {  margin: 1,  scale: 4,               // vorher 6
  errorCorrectionLevel: 'M' // statt 'Q'/'H'
});
      btnCopy.onclick=async()=>{ try{ await navigator.clipboard.writeText(url); toast('Link kopiert'); }catch{ toast('Konnte nicht kopieren'); } };
      btnOpen.onclick=()=>{ window.open(url,'_blank'); };
      btnClose.onclick=()=>{ el.remove(); };
    }

function addParam(url, key, val){
  try {
    const u = new URL(url, location.href);
    if (!u.searchParams.has(key)) u.searchParams.set(key, val);
    return u.toString();
  } catch { return url; }
}
    
// Legacy publish() wrapper - redirects to canonical window.publishScene
async function publish(){
  if (typeof window.publishScene === 'function') {
    return await window.publishScene();
  } else {
    alert('publishScene is not available yet');
  }
}

// Canonical publishScene implementation (robust, handles export, fallbacks, FormData, upload, robust viewer URL)
(function(){
  const AREA = (window.__AREA = window.__AREA || {});
  const file = (sel)=> (document.querySelector(sel)?.files?.[0]) || null;

  const buildSceneJson = window.buildSceneJson;

  window.publishScene = async function publishScene(){
    try{
      // 1) Determine sceneId from projNamePill or fallback, with user prompt
      const projNamePill = document.getElementById('projNamePill');
      const projectName = projNamePill?.textContent?.trim() || 'Unbenanntes Projekt';
      const sanitizeId = (s) => (s||'scene').toLowerCase().replace(/[^a-z0-9-_]+/g,'-').replace(/^-+|-+$/g,'').slice(0,64)||'scene';
      const defaultSceneId = sanitizeId(AREA?.sceneId || projectName);
      const userSceneId = prompt('Scene ID:', defaultSceneId);
      if (!userSceneId) {
        // User cancelled
        return;
      }
      const sceneId = sanitizeId(userSceneId);

      // 2) Export GLB via exportSceneGLB; if null and __origGlb present, fallback to original GLB
      let glbBlob = null;
      let glbSource = 'none';
      try {
        glbBlob = await exportSceneGLB();
        AREA.files = AREA.files || {};
        AREA.files.glb = glbBlob;
        glbSource = 'export';
        console.log('[publish] Export: GLB erzeugt via exportSceneGLB');
      } catch (e) {
        console.warn('[publish] Export fehlgeschlagen, versuche Fallback:', e);
      }

      // Fallback: wenn Original vorhanden und exportiertes GLB keine animations[] enthält → Original nutzen
      if (AREA.__origGlb){
        let mustFallback = false;
        if (glbBlob){
          const hasAnim = await window.hasAnimationsInGlbBlob(glbBlob);
          if (!hasAnim){
            console.warn('[publish] Exportiertes GLB ohne animations[] – fallback auf Original-GLB.');
            mustFallback = true;
          }
        } else {
          mustFallback = true;
        }
        if (mustFallback){
          glbBlob = new Blob([AREA.__origGlb], { type:'model/gltf-binary' });
          glbSource = 'fallback';
          console.log('[publish] GLB source: fallback to original GLB (Passthrough), size:', AREA.__origGlb.byteLength, 'bytes');
        }
      }

      if (glbSource === 'export'){
        console.log('[publish] GLB source: export (via exportSceneGLB)');
      }

      if (!glbBlob){
        alert('Kein GLB exportiert/importiert. Bitte ein GLB laden oder exportieren.');
        return;
      }

      // 3) Build scene.json (existing logic)
      const sceneJson = buildSceneJson();
      const sceneText = JSON.stringify(sceneJson);

      // 4) Build FormData AFTER creation
      const fd = new FormData();
      fd.append('sceneId', sceneId);
      fd.append('file', new Blob([sceneText], {type:'application/json'}), 'scene.json');
      fd.append('file', glbBlob, 'scene.glb');

      // 5) Optional assets: USDZ, poster, audio
      const usdzF   = file('#fileUsdz');
      if (usdzF) fd.append('file', usdzF, 'model.usdz');

      const posterF = file('#file-poster');
      if (posterF) {
        fd.append('file', posterF, posterF.name);
      } else {
        // Try capturing poster from canvas if not provided
        try {
          const snap = await capturePosterBlob(0.78);
          if (snap) {
            fd.append('file', snap, 'poster.jpg');
            console.log('[editor] Poster: Canvas-Snapshot angehängt');
          }
        } catch (e) { console.warn('Poster-Snapshot fehlgeschlagen:', e); }
      }

      const audioF  = file('#file-audio');
      if (audioF) {
        fd.append('file', audioF, 'audio.mp3');
      } else {
        // Try finding audio from scene objects
        const ai = findFirstAudio();
        if (ai?.fromFile) {
          fd.append('file', ai.fromFile, 'audio.mp3');
          console.log('[editor] Audio: aus Media-Objekt (File) hinzugefügt');
        } else if (ai?.fromDataUrl) {
          const b = await dataUrlToBlob(ai.fromDataUrl);
          fd.append('file', new File([b], 'audio.mp3', { type: b.type || 'audio/mpeg' }), 'audio.mp3');
          console.log('[editor] Audio: aus data:URL hinzugefügt');
        }
      }

      // 6) Publish to endpoint
      const PUBLISH_URL = AREA?.publishUrl || AREA?.PUBLISH_ENDPOINT || 'https://area-publish-proxy.area-webar.workers.dev/publish';
      const PUBLISH_KEY = AREA?.publishKey || AREA?.PUBLISH_KEY || '';

      const res = await fetch(PUBLISH_URL, {
        method:'POST',
        headers:{ 'X-AREA-Key': PUBLISH_KEY },
        body: fd
      });
      if (!res.ok){
        const t = await res.text().catch(()=>String(res.status));
        alert('Publish fehlgeschlagen: ' + t);
        return;
      }

      // 7) Compute robust viewer URL
      const json = await res.json().catch(()=>null);
      console.log('[publish] POST result:', json);
      
      const viewerBase   = AREA?.VIEWER_BASE || 'https://area-viewer.pages.dev';
      const workerOrigin = AREA?.FILE_BASE || (new URL(PUBLISH_URL).origin);
      const mode = (function getAnchorSel(){
        const sel = document.getElementById('anchorMode');
        return sel?.value || 'surface-webxr';
      })();

      const robustUrl = buildRobustViewerUrl({ mode, sceneId, workerOrigin, viewerBase });
      console.log('[publish] Final viewer URL:', robustUrl);

      // Show share panel with QR code and link
      showSharePanel(robustUrl);

      // Copy to clipboard (best-effort)
      try { 
        await navigator.clipboard.writeText(robustUrl); 
        console.log('[publish] URL copied to clipboard');
      } catch (e) { 
        console.warn('[publish] Could not copy to clipboard:', e);
      }

      // Open viewer URL (best-effort)
      try {
        window.open(robustUrl, '_blank', 'noopener');
        console.log('[publish] Opened viewer URL in new tab');
      } catch (e) {
        console.warn('[publish] Could not open new tab:', e);
      }
    }catch(e){
      console.warn(e);
      alert('Publish-Fehler: ' + (e?.message || String(e)));
    }
  };
})();

async function previewDraft(){
  const cfg = window.__AREA || {};
  const EP  = (cfg.PUBLISH_ENDPOINT || '').trim();
  const KEY = (cfg.PUBLISH_KEY || '').trim(); // beim Proxy i. d. R. leer
  if (!EP) { alert('Draft-Preview ist nicht konfiguriert: window.__AREA.PUBLISH_ENDPOINT fehlt.'); return; }

  // 1) Draft-ID bauen (einzigartig, kompakt)
  const baseId = sanitizeId(projectName) || 'scene';
  const sceneId = `${baseId}-draft-${Date.now().toString(36).slice(-5)}`;

  try{
    toast('Exportiere Szene für Draft…');

    // 2) GLB exportieren (wie publish)
    const mode = getAnchorSel();
    const isAR = (mode === 'surface-webxr' || mode === 'image' || mode === 'native');
    const glbBlob = await exportSceneGLB({ targetSizeMeters: isAR ? 1.0 : null });

    // Magic bytes check (glTF)
    {
      const ab = await glbBlob.arrayBuffer();
      const u8 = new Uint8Array(ab, 0, 4);
      if (!(u8[0]===0x67 && u8[1]===0x6C && u8[2]===0x54 && u8[3]===0x46)) {
        throw new Error('Exportierte Datei ist kein GLB (fehlende "glTF"-Magic-Bytes).');
      }
    }

    // 3) FormData bauen
    const form = new FormData();
    form.append('sceneId', sceneId);
    form.append('file', new File([glbBlob], 'scene.glb', { type:'model/gltf-binary' }));

    const workerOrigin = (window.__AREA?.FILE_BASE || new URL(EP).origin);

    if (mode === 'scene-viewer' || mode === 'surface-guided'){
      // Poster beilegen: zuerst Custom, sonst Canvas-Snapshot
      let posterBlob = customPosterBlob || null;
      if (!posterBlob){
        try { posterBlob = await capturePosterBlob(0.9); } catch {}
      }
      if (posterBlob){
        form.append('file', new File([posterBlob], 'poster.jpg', { type:'image/jpeg' }));
      }
      // Scene-Viewer JSON (relative Pfade)
      const sceneJsonSV = buildSceneViewerJSON_CF();
      form.append('file', new File([JSON.stringify(sceneJsonSV, null, 2)], 'scene.json', { type:'application/json' }));
    } else {
      // --- NEU: USDZ-Upload (optional) einlesen
      const usdzFile = document.getElementById('fileUsdz')?.files?.[0] || null;
      if (usdzFile){
        form.append('file', new File([usdzFile], 'scene.usdz', { type:'model/vnd.usdz+zip' }));
      }

      // WebXR / Image / Native JSON
      const nativeGlb = val('nativeGlbUrl');
      const nativeUsd = val('nativeUsdzUrl');

      const glbUrl  = (mode === 'native' && nativeGlb)
                        ? nativeGlb
                        : `${workerOrigin}/scenes/${encodeURIComponent(sceneId)}/scene.glb`;

      const usdzUrl = (mode === 'native' && usdzFile)
                        ? `${workerOrigin}/scenes/${encodeURIComponent(sceneId)}/scene.usdz`
                        : (mode === 'native' && nativeUsd ? nativeUsd : null);

      const targetUrl = (mode === 'image' && (document.getElementById('imageTargetUrl')?.value||'').trim())
                        ? document.getElementById('imageTargetUrl').value.trim()
                        : null;

      const sceneJson = buildSceneJSON({
        sceneId,
        title: projectName,
        mode,
        glbUrl,
        usdzUrl,
        targetUrl
      });
      form.append('file', new File([JSON.stringify(sceneJson, null, 2)], 'scene.json', { type:'application/json' }));
    }

    // Optionales Audio relativ beilegen
    const a = findFirstAudio();
if (a){
  let audioBlob = null;
  if (a.fromFile){
    audioBlob = a.fromFile; // File direkt
  } else if (a.fromDataUrl){
    audioBlob = await dataUrlToBlob(a.fromDataUrl); // data: → Blob
  } else if (a.fromBlobUrl){
    // blob: → Blob (z. B. frisch importierte Datei)
    audioBlob = await (await fetch(a.fromBlobUrl)).blob();
  }
  if (audioBlob){
    form.append('file', new File([audioBlob], 'audio.mp3', { type:(audioBlob.type||'audio/mpeg') }));
  }
}


    // 4) Draft-Flag mitsenden (Worker darf es ignorieren – ist nur ein Hint)
    form.append('draft', '1');

    toast('Draft hochladen…');
    const headers = { 'Accept': 'application/json' };
    if (KEY) headers['X-AREA-Key'] = KEY;

    const res = await fetch(EP, { method:'POST', body: form, headers });
    if (!res.ok){
      const t = await res.text().catch(()=> '');
      throw new Error(t || ('HTTP '+res.status));
    }
    const json = await res.json().catch(()=> ({}));

    // 5) Viewer-URL aufbauen (wie publish), mit Cache-Bust
    const viewerBase  = (cfg.VIEWER_BASE || 'https://area-viewer.pages.dev');
    const entryByMode = {
      'surface-webxr': '/surface-ar/webxr.html',
      'native':        '/surface-ar/index.html',
      'image':         '/image-ar/viewer.html',
      'scene-viewer':  '/scene-viewer/index.html',
      'surface-guided':'/surface-ar/guided.html',
      'surface-area-viewer':'/surface-ar/area-viewer.html'
    };
    const entryDefault = entryByMode[mode] || '/surface-ar/webxr.html';

    let url = `${viewerBase}${entryDefault}?scene=${encodeURIComponent(sceneId)}&base=${encodeURIComponent(workerOrigin)}&ts=${Date.now()}`;

    // Worker-URL bevorzugen, wenn vorhanden – Pfad/Params korrigieren
    const raw = (json.viewerUrl || '').trim();
    if (raw){
      try{
        const u = new URL(raw, viewerBase);
        const want = entryByMode[mode];
        if (want && u.pathname !== want){
          if (u.pathname === '/' || u.pathname.endsWith('/index.html') || u.pathname === '/webxr.html' || u.pathname === '/surface-ar/') {
            u.pathname = want;
          }
        }
        const b = (u.searchParams.get('base') || '').trim();
        if (!b || b.startsWith('http://internal') || b.startsWith('https://internal')){
          u.searchParams.set('base', workerOrigin);
        }
        if (mode === 'native') u.searchParams.set('force','native');
        u.searchParams.set('ts', String(Date.now())); // Cache-Bust
        url = u.toString();
      }catch{}
    }

    window.open(url, '_blank', 'noopener');
    toast('Draft-Preview geöffnet');
  } catch(err){
    console.error(err);
    alert('Draft-Preview fehlgeschlagen: ' + (err?.message || err));
  }
}

// … im Projektmenü-Hook:
document.getElementById('btn-preview-draft')?.addEventListener('click', ()=>{
  // Menü schließen wie bei den anderen Buttons:
  document.getElementById('projectMenu')?.classList.remove('open');
  document.getElementById('btn-project-menu')?.setAttribute('aria-expanded','false');
  previewDraft();
});



// (duplicate autoscale/exportSceneGLB removed – unified version is defined above)   


    // Hint FAB + Projektmenü
    (function(){
      const hint=$('.hint'); const fab=$('#hintFab'); if(!hint||!fab) return; let timer=null;
      function open(){ if(timer){clearTimeout(timer);timer=null;} hint.classList.remove('hidden'); fab.setAttribute('aria-expanded','true'); fab.textContent='×'; }
      function close(){ if(timer){clearTimeout(timer);timer=null;} hint.classList.add('hidden'); fab.setAttribute('aria-expanded','false'); fab.textContent='i'; }
      fab.addEventListener('mouseenter', open);
      fab.addEventListener('mouseleave', ()=>{ timer=setTimeout(()=>{ if(!hint.matches(':hover')) close(); },200); });
      hint.addEventListener('mouseleave', ()=>{ timer=setTimeout(()=>{ if(!fab.matches(':hover')) close(); },100); });
      hint.addEventListener('mouseenter', ()=>{ if(timer){clearTimeout(timer);timer=null;} });
      fab.addEventListener('click', e=>{ e.preventDefault(); if(hint.classList.contains('hidden')) open(); else close(); }, {passive:false});
    })();

    (function(){
      const menu=$('#projectMenu'); const btn=$('#btn-project-menu');
      function close(){ menu.classList.remove('open'); btn.setAttribute('aria-expanded','false'); }
      btn.addEventListener('click', e=>{ e.stopPropagation(); menu.classList.toggle('open'); btn.setAttribute('aria-expanded', menu.classList.contains('open')?'true':'false'); });
      document.addEventListener('click', e=>{ if(!menu.contains(e.target)) close(); });
      window.addEventListener('keydown', e=>{ if(e.key==='Escape') close(); });

      $('#btn-new').addEventListener('click', ()=>{ close(); if(!confirm('Aktuelle Szene leeren und neues Projekt anlegen?')) return; setProjectName(prompt('Projektname:', 'Neues AR-Projekt')||'Unbenanntes Projekt'); $('#btn-clear').click(); });
      $('#btn-save').addEventListener('click', ()=>{ close(); saveProject({saveAs:false}); });
      $('#btn-save-as').addEventListener('click', ()=>{ close(); saveProject({saveAs:true}); });
      $('#file-project').addEventListener('change', e=>{ close(); const f=e.target.files?.[0]; if(!f){ e.target.value=''; return;} importProjectFile(f); e.target.value=''; });
      $('#btn-preview').addEventListener('click', ()=>{ close(); previewModules(); });
      $('#btn-publish').addEventListener('click', ()=>{ close(); publish(); });
    })();

    // Render
    const clock=new THREE.Clock();
    function render(){
      requestAnimationFrame(render);
      const dt=clock.getDelta();
      forEachRec(o=>{ if(o.mixer) o.mixer.update(dt); });
      controls.update();
      renderer.clear(); composer.render(); renderer.clearDepth(); renderer.render(overlayScene,camera);
    }

    // Start
    setProjectName(projectName);
    buildRoom(parseFloat($('#roomSize').value)||24);
    let roomBuildRAF=0;
    function scheduleRoomRebuild(){ if(roomBuildRAF) return; roomBuildRAF=requestAnimationFrame(()=>{ buildRoom(parseFloat($('#roomSize').value)||24); roomBuildRAF=0; }); }
    $('#roomSize').addEventListener('input', scheduleRoomRebuild);
    $('#gridIntensity').addEventListener('input', scheduleRoomRebuild);
    $('#gridIntensity').addEventListener('change', scheduleRoomRebuild);
    $('#gridVisible').addEventListener('change', ()=>{ const v=$('#gridVisible').checked; [gridNear,gridFar,axisX,axisZ].forEach(o=>o&&(o.visible=v)); });

    requestAnimationFrame(()=> onResize());
    updateToolButtons(); applySnap(); setSpace('local'); updateGroupButtons(); updateOutlineSelection();

    window.addEventListener('keydown', (e)=>{
      const t=e.target; if(t && (t.tagName==='INPUT'||t.tagName==='TEXTAREA'||t.isContentEditable)) return;
      if(tcontrols?.dragging) return;
      const k=e.key.toLowerCase();
      if(k==='w') { tcontrols.setMode('translate'); updateToolButtons(); }
      else if(k==='e') { tcontrols.setMode('rotate'); updateToolButtons(); }
      else if(k==='r') { tcontrols.setMode('scale'); updateToolButtons(); }
      else if(k==='d') { e.preventDefault(); $('#btn-duplicate').click(); }
      else if(k==='f') { e.preventDefault(); $('#btn-floor').click(); }
      else if(k>='1' && k<='5' && e.shiftKey){ saveBookmark(parseInt(k,10)-1); }
      else if(k>='1' && k<='5' && !e.shiftKey){ recallBookmark(parseInt(k,10)-1); }
      else if(k==='g' && (e.ctrlKey||e.metaKey) && !e.shiftKey){ e.preventDefault(); $('#btn-group').click(); }
      else if(k==='g' && (e.ctrlKey||e.metaKey) && e.shiftKey){ e.preventDefault(); $('#btn-ungroup').click(); }
    });

   /* === Theme Toggle (Slate ↔ Aurora ↔ Nebula) === */
(function(){
  const html = document.documentElement;

  const storage = (() => {
    try { const s = localStorage; s.setItem('__t','1'); s.removeItem('__t'); return s; }
    catch { return null; }
  })();

  // ... in deinem Theme-Block:
const THEMES = ['theme-slate','theme-aurora','theme-nebula'];

function setTheme(theme){
  THEMES.forEach(t => html.classList.remove(t));
  html.classList.add(theme);
  try { storage?.setItem('theme', theme); } catch {}
  requestAnimationFrame(() => {
    window.__applyThemeToThree?.();
    syncThemeToggleUI();       // <-- NEU: UI nachziehen
  });
}

function syncThemeToggleUI(){
  const cur = THEMES.find(t => html.classList.contains(t)) || 'theme-nebula';
  const map = { 'theme-slate':'th-slate', 'theme-aurora':'th-aurora', 'theme-nebula':'th-nebula' };
  const id = map[cur];
  const el = document.getElementById(id);
  if (el) el.checked = true;
}

// beim Start richtige Radio-Option setzen
requestAnimationFrame(syncThemeToggleUI);

// Change-Events binden
document.querySelectorAll('.theme-toggle3 input[name="theme3"]').forEach(inp=>{
  inp.addEventListener('change', (e)=> setTheme(e.target.value));
});

// Optional: Taste „T“ zum Durchschalten beibehalten (dein Code bleibt)


  // Initial
  const saved = storage?.getItem('theme');
  setTheme(THEMES.includes(saved) ? saved : 'theme-nebula'); // ← Nebula als frischer Default
  scheduleRoomRebuild(); // ← damit Grid-Farben zum Theme passen

  const btn = document.getElementById('themeToggle');
  const cycle = () => {
    const current = THEMES.find(t => html.classList.contains(t)) || THEMES[0];
    const next = THEMES[(THEMES.indexOf(current)+1) % THEMES.length];
    setTheme(next);
    scheduleRoomRebuild(); // Grid+Achsen neu einfärben für Nebula/Slate/Aurora
    // Menü schließen (UX)
    const menu = document.getElementById('projectMenu');
    const menuBtn = document.getElementById('btn-project-menu');
    menu?.classList.remove('open');
    menuBtn?.setAttribute('aria-expanded','false');
  };
  btn?.addEventListener('click', (e)=>{ e.preventDefault(); e.stopPropagation(); cycle(); });

  // Shortcut: Taste „T“ with guard (inputs/selects/contenteditable or inside #svBlock)
  window.addEventListener('keydown', (e)=>{
    if ((e.key||'').toLowerCase() !== 't' || e.ctrlKey || e.metaKey || e.altKey) return;
    const el = e.target;
    if (el && el.closest && el.closest('input,textarea,select,[contenteditable="true"],#svBlock')) return;
    cycle();
  });
})();


       render();
  </script>

<script id="patch-safety" type="module">
/* --- ARea Editor Runtime Patch (WebGL/video) --- */
(function(){
  // Cap an overly high DPR (helps avoid max renderbuffer overflows on some mobiles)
  try {
    const dpr = window.devicePixelRatio || 1;
    // Expose a helper so your code can use it instead of raw devicePixelRatio
    window.__AREA_SAFE_DPR__ = Math.min(2, dpr);
  } catch (e) {}

  // Guard: ensure the stage gets a reasonable size before 3D init
  function ensureStageMinSize(){
    const stage = document.getElementById('stage') || document.getElementById('viewport') || null;
    if (!stage) return;
    const r = stage.getBoundingClientRect();
    if (r.width < 32) stage.style.minWidth = '320px';
    if (r.height < 32) stage.style.minHeight = '240px';
  }
  ensureStageMinSize();
  try {
    const ro = new ResizeObserver(()=>ensureStageMinSize());
    const stageEl = document.getElementById('stage') || document.getElementById('viewport');
    if (stageEl) ro.observe(stageEl);
  } catch(e) {}

  // Safe VideoTexture creator: starts with 1x1 placeholder, swaps when metadata is ready
  // Usage: replace `createSafeVideoTexture(THREE, video)` with `createSafeVideoTexture(THREE, video)`
  window.createSafeVideoTexture = function(THREE, video) {
    try {
      if (video && video.videoWidth && video.videoHeight) {
        // already ready
        const tx = createSafeVideoTexture(THREE, video);
        tx.minFilter = THREE.LinearFilter;
        tx.magFilter = THREE.LinearFilter;
        tx.generateMipmaps = false;
        return tx;
      }
      // placeholder 1x1
      const canvas = document.createElement('canvas');
      canvas.width = 1; canvas.height = 1;
      const ctx = canvas.getContext('2d');
      if (ctx) { ctx.fillStyle = '#000'; ctx.fillRect(0,0,1,1); }
      const tx = createSafeVideoTexture(THREE, canvas);
      tx.minFilter = THREE.LinearFilter;
      tx.magFilter = THREE.LinearFilter;
      tx.generateMipmaps = false;

      const onReady = () => {
        if (video.videoWidth && video.videoHeight) {
          tx.image = video;
          tx.needsUpdate = true;
          video.removeEventListener('loadedmetadata', onReady);
          video.removeEventListener('loadeddata', onReady);
          video.removeEventListener('canplay', onReady);
        }
      };
      video.addEventListener('loadedmetadata', onReady);
      video.addEventListener('loadeddata', onReady);
      video.addEventListener('canplay', onReady);
      return tx;
    } catch (e) {
      console.warn('createSafeVideoTexture failed, falling back:', e);
      try { return createSafeVideoTexture(THREE, video); } catch(e2) { return null; }
    }
  };
})();
</script>

</body>
</html>
